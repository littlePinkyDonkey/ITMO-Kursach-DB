CREATE TYPE PRODUCER_ROLES AS ENUM ('producer', 'executive producer', 'co-producer', 'associate producer', 
 'assistant producer', 'line producer', 'administrative producer', 'creative producer', 'information producer');
CREATE TYPE EDITOR_POSITIONS AS ENUM ('literature editor', 'technical editor' , 'art editor', 'main editor');
CREATE TYPE ARTIST_TYPES AS ENUM ('character artist', 'battle artist', 'location artist', 'background artist', 'effect artist', 
 'animation artist', 'coloring artist');
CREATE TYPE PROCESS_STATUS AS ENUM ('started', 'in process', 'revision', 'finished');
CREATE TYPE INSERTION_LOCATIONS AS ENUM ('the beginning', 'the middle', 'the end');
CREATE TYPE SOUND_TYPES AS ENUM ('music', 'noises');
CREATE TYPE DIGITIZATION_TYPES AS ENUM ('adding contrast, then scanning', 'scanning, then adding contrast');
CREATE TYPE REVISION_TYPES AS ENUM ('full revision', 'part revision');
CREATE TYPE COLORING_TYPES AS ENUM ('colored', 'black-white');
CREATE TYPE VOICE_ACTING_TYPES AS ENUM ('preliminary', 'follow-up');
CREATE TYPE PLOT_TYPES AS ENUM ('main', 'additional', 'spin-off');
CREATE TYPE LOCATION_TYPES AS ENUM ('field', 'forest', 'city', 'village', 'jungle', 'lake', 'mounatains', 'desert', 'cave', 'waterfall', 'castle');
CREATE TYPE ABILITY_TYPES AS ENUM ('attack', 'defence', 'heal', 'chatting');
CREATE TYPE USING_TECHNOLOGIES AS ENUM ('drawings', 'dolls', '3D');
CREATE TYPE ARTIFACT_TYPES AS ENUM ('image', 'video', 'text', 'music', 'sounds');
CREATE TYPE EFFECT_LEVELS AS ENUM('AAA', 'AA', 'A', 'BBB', 'BB', 'B', 'CCC', 'CC', 'C');
CREATE TYPE RECORDING_ACTORS_POSITIONS AS ENUM('main', 'second_role');

CREATE TABLE users (
    USER_ID SERIAL PRIMARY KEY,
    MAIN_WORKER_ID INTEGER UNIQUE REFERENCES workers(MAIN_WORKER_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    LOGIN VARCHAR(32) NOT NULL,
    USER_PASSWORD VARCHAR(32) NOT NULL,
    SALT VARCHAR(32) NOT NULL
);

/*
*сущность рабочие и все её характеристические сущности
*/
CREATE TABLE workers(
    MAIN_WORKER_ID SERIAL,
    NAME VARCHAR(32) NOT NULL,
    SECOND_NAME VARCHAR(32) NOT NULL,
    GENDER VARCHAR(32) NOT NULL,
    AGE INTEGER NOT NULL,
    PLACE_OF_BIRTH TEXT NOT NULL,
    CONSTRAINT WORKERS_PK PRIMARY KEY(MAIN_WORKER_ID),
    CONSTRAINT WORKERS_AGE_CHECK CHECK(AGE > 0 AND AGE < 120)
);
CREATE INDEX workers_full_name_idx ON workers (SECOND_NAME, NAME);
CREATE INDEX workers_id_idx ON workers USING hash (MAIN_WORKER_ID);

CREATE TABLE storyboard_artists(
    WORKER_ID SERIAL,
    MAIN_WORKER_ID INTEGER UNIQUE REFERENCES workers(MAIN_WORKER_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    CONSTRAINT STORYBOARD_ARTISTS_PK PRIMARY KEY(WORKER_ID)
);
CREATE INDEX storyboard_artists_id_idx ON storyboard_artists USING hash (WORKER_ID);
CREATE INDEX storyboard_artists_main_worker_id_idx ON storyboard_artists USING hash (MAIN_WORKER_ID);

CREATE TABLE producers(
    WORKER_ID SERIAL,
    MAIN_WORKER_ID INTEGER UNIQUE REFERENCES workers(MAIN_WORKER_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    ROLE PRODUCER_ROLES NOT NULL,
    CONSTRAINT PRODUCERS_PK PRIMARY KEY(WORKER_ID)
);
CREATE INDEX producers_id_idx ON producers USING hash (WORKER_ID);
CREATE INDEX producers_main_worker_id_idx ON producers USING hash (MAIN_WORKER_ID);

CREATE TABLE audio_specialist(
    WORKER_ID SERIAL,
    MAIN_WORKER_ID INTEGER UNIQUE REFERENCES workers(MAIN_WORKER_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    CONSTRAINT AUDIO_SPECIALIST_PK PRIMARY KEY(WORKER_ID)
);
CREATE INDEX audio_specialist_id_idx ON audio_specialist USING hash (WORKER_ID);
CREATE INDEX audio_specialist_main_worker_id_idx ON audio_specialist USING hash (MAIN_WORKER_ID);

CREATE TABLE digitizers(
    WORKER_ID SERIAL,
    MAIN_WORKER_ID INTEGER UNIQUE REFERENCES workers(MAIN_WORKER_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    CONSTRAINT DIGITIZERS_PK PRIMARY KEY(WORKER_ID)
);
CREATE INDEX digitizers_id_idx ON digitizers USING hash (WORKER_ID);
CREATE INDEX digitizers_main_worker_id_idx ON digitizers USING hash (MAIN_WORKER_ID);

CREATE TABLE smoothing_specialist(
    WORKER_ID SERIAL,
    MAIN_WORKER_ID INTEGER UNIQUE REFERENCES workers(MAIN_WORKER_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    CONSTRAINT SMOOTHING_SPECIALIST PRIMARY KEY(WORKER_ID)
);
CREATE INDEX smoothing_specialist_id_idx ON smoothing_specialist USING hash (WORKER_ID);
CREATE INDEX smoothing_specialist_main_worker_id_idx ON smoothing_specialist USING hash (MAIN_WORKER_ID);

CREATE TABLE art_director(
    WORKER_ID SERIAL,
    MAIN_WORKER_ID INTEGER UNIQUE REFERENCES workers(MAIN_WORKER_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    CONSTRAINT ART_DIRECTOR_PK PRIMARY KEY(WORKER_ID)
);
CREATE INDEX art_director_id_idx ON art_director USING hash (WORKER_ID);
CREATE INDEX art_director_main_worker_id_idx ON art_director USING hash (MAIN_WORKER_ID);

CREATE TABLE screenwriters(
    WORKER_ID SERIAL,
    MAIN_WORKER_ID INTEGER UNIQUE REFERENCES workers(MAIN_WORKER_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    FILMS_NUMBER INTEGER NOT NULL,
    GENRES VARCHAR(32)[] NOT NULL,
    CONSTRAINT SCREENWRITERS_PK PRIMARY KEY(WORKER_ID),
    CONSTRAINT SCREENWRITER_FILMS_NUMBER_CHECK CHECK(FILMS_NUMBER >= 0)
);
CREATE INDEX screenwriters_id_idx ON screenwriters USING hash (WORKER_ID);
CREATE INDEX screenwriters_main_worker_id_idx ON screenwriters USING hash (MAIN_WORKER_ID);

CREATE TABLE regisseurs(
    WORKER_ID SERIAL,
    MAIN_WORKER_ID INTEGER UNIQUE REFERENCES workers(MAIN_WORKER_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    FILMS_NUMBER INTEGER NOT NULL,
    GENRES VARCHAR(32)[] NOT NULL,
    CONSTRAINT REGISSEURS_PK PRIMARY KEY(WORKER_ID),
    CONSTRAINT REGISSEURS_FILMS_NUMBER_CHECK CHECK(FILMS_NUMBER >= 0)
);
CREATE INDEX regisseurs_id_idx ON regisseurs USING hash (WORKER_ID);
CREATE INDEX regisseurs_main_worker_id_idx ON regisseurs USING hash (MAIN_WORKER_ID);

CREATE TABLE roles_designers(
    WORKER_ID SERIAL,
    MAIN_WORKER_ID INTEGER UNIQUE REFERENCES workers(MAIN_WORKER_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    CONSTRAINT ROLES_DESIGNERS_PK PRIMARY KEY(WORKER_ID)
);
CREATE INDEX roles_designers_id_idx ON roles_designers USING hash (WORKER_ID);
CREATE INDEX roles_designers_main_worker_id_idx ON roles_designers USING hash (MAIN_WORKER_ID);

CREATE TABLE recording_actors(
    WORKER_ID SERIAL,
    MAIN_WORKER_ID INTEGER UNIQUE REFERENCES workers(MAIN_WORKER_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    POSITION RECORDING_ACTORS_POSITIONS NOT NULL,
    CONSTRAINT RECORDING_ACTORS_PK PRIMARY KEY(WORKER_ID)
);
CREATE INDEX recording_actors_id_idx ON recording_actors USING hash (WORKER_ID);
CREATE INDEX recording_actors_main_worker_id_idx ON recording_actors USING hash (MAIN_WORKER_ID);

CREATE TABLE editors(
    WORKER_ID SERIAL,
    MAIN_WORKER_ID INTEGER UNIQUE REFERENCES workers(MAIN_WORKER_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    GENRES VARCHAR(32)[] NOT NULL,
    POSITION EDITOR_POSITIONS NOT NULL,
    CONSTRAINT EDITORS_PK PRIMARY KEY(WORKER_ID)
);
CREATE INDEX editors_id_idx ON editors USING hash (WORKER_ID);
CREATE INDEX editors_main_worker_id_idx ON editors USING hash (MAIN_WORKER_ID);

CREATE TABLE artists(
    WORKER_ID SERIAL,
    MAIN_WORKER_ID INTEGER REFERENCES workers(MAIN_WORKER_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    ARTIST_TYPE ARTIST_TYPES NOT NULL,
    USING_TECHNOLOGY USING_TECHNOLOGIES NOT NULL,
    CONSTRAINT ARTISTS_PK PRIMARY KEY(WORKER_ID)
);
CREATE INDEX artists_id_idx ON artists USING hash (WORKER_ID);
CREATE INDEX artists_main_worker_id_idx ON artists USING hash (MAIN_WORKER_ID);

/*
*сущность процессы и все её характеристические сущности
*/
CREATE TABLE processes(
    MAIN_PROCESS_ID SERIAL,
    DURATION INTEGER NOT NULL,
    DEADLINE_DATE DATE NOT NULL,
    DESCRIPTION TEXT NOT NULL,
    STATUS PROCESS_STATUS NOT NULL,
    ESTIMATION_TIME INTERVAL NOT NULL,
    START_DATE DATE NOT NULL,
    CONSTRAINT PROCESSES_PK PRIMARY KEY(MAIN_PROCESS_ID),
    CONSTRAINT PROCESSES_DURATION_CHECK CHECK(DURATION > 0),
    CONSTRAINT PROCESS_DATES_CHECk CHECK(DEADLINE_DATE > START_DATE)
);
CREATE INDEX processes_id_idx ON processes USING hash (MAIN_PROCESS_ID);
CREATE INDEX process_status_idx ON processes (STATUS);

CREATE TABLE storyboard_process(
    PROCESS_ID SERIAL,
    MAIN_PROCESS_ID INTEGER UNIQUE REFERENCES processes(MAIN_PROCESS_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    FRAME_NUMBER INTEGER NOT NULL,
    CONSTRAINT STORYBOARD_PROCESS_PK PRIMARY KEY(PROCESS_ID),
    CONSTRAINT STORYBOARD_PROCESS_FRAME_NUMBER_CHECK CHECK(FRAME_NUMBER >= 0)
);
CREATE INDEX storyboard_process_id_idx ON storyboard_process USING hash (PROCESS_ID);
CREATE INDEX storyboard_process_main_process_id_idx ON storyboard_process USING hash (MAIN_PROCESS_ID);
CREATE INDEX frame_number_idx ON storyboard_process (FRAME_NUMBER);

CREATE TABLE advertising_process(
    PROCESS_ID SERIAL,
    MAIN_PROCESS_ID INTEGER UNIQUE REFERENCES processes(MAIN_PROCESS_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    INSERTION_LOCATION INSERTION_LOCATIONS NOT NULL,
    CONSTRAINT ADVERTISNG_PROCESS_PK PRIMARY KEY(PROCESS_ID)
);
CREATE INDEX advertising_process_id_idx ON advertising_process USING hash (PROCESS_ID);
CREATE INDEX advertising_process_main_process_id_idx ON advertising_process USING hash (MAIN_PROCESS_ID);
CREATE INDEX insertion_location_idx ON advertising_process (INSERTION_LOCATION);

CREATE TABLE adding_sound_process(
    PROCESS_ID SERIAL,
    MAIN_PROCESS_ID INTEGER UNIQUE REFERENCES processes(MAIN_PROCESS_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    SOUND_TYPE SOUND_TYPES NOT NULL,
    CONSTRAINT ADDING_SOUND_PROCESS_PK PRIMARY KEY(PROCESS_ID)
);
CREATE INDEX adding_sound_process_id_idx ON adding_sound_process USING hash (PROCESS_ID);
CREATE INDEX adding_sound_process_main_process_id_idx ON adding_sound_process USING hash (MAIN_PROCESS_ID);
CREATE INDEX sound_type ON adding_sound_process (SOUND_TYPE);

CREATE TABLE digitization_process(
    PROCESS_ID SERIAL,
    MAIN_PROCESS_ID INTEGER UNIQUE REFERENCES processes(MAIN_PROCESS_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    SKETCHES_NUMBER INTEGER NOT NULL,
    DIGITIZATION_TYPE DIGITIZATION_TYPES NOT NULL,
    CONSTRAINT DIGITIZATION_PROCESS_PK PRIMARY KEY(PROCESS_ID),
    CONSTRAINT DIGITIZATION_PROCESS_SKETCHES_NUMBER_CHECK CHECK(SKETCHES_NUMBER >= 0)
);
CREATE INDEX digitization_process_id_idx ON digitization_process USING hash (PROCESS_ID);
CREATE INDEX digitization_process_main_process_id_idx ON digitization_process USING hash (MAIN_PROCESS_ID);
CREATE INDEX digitization_type_idx ON digitization_process (DIGITIZATION_TYPE);

CREATE TABLE smoothing_process(
    PROCESS_ID SERIAL,
    MAIN_PROCESS_ID INTEGER UNIQUE REFERENCES processes(MAIN_PROCESS_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    CONSTRAINT SMOOTHING_PROCESS_PK PRIMARY KEY(PROCESS_ID)
);
CREATE INDEX smoothing_process_id_idx ON smoothing_process USING hash (PROCESS_ID);
CREATE INDEX smoothing_process_main_process_id_idx ON smoothing_process USING hash (MAIN_PROCESS_ID);

CREATE TABLE revisions_process(
    PROCESS_ID SERIAL,
    MAIN_PROCESS_ID INTEGER UNIQUE REFERENCES processes(MAIN_PROCESS_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    REVISION_TYPE REVISION_TYPES NOT NULL,
    CONSTRAINT REVISIONS_PROCESS PRIMARY KEY(PROCESS_ID)
);
CREATE INDEX revisions_process_id_idx ON revisions_process USING hash (PROCESS_ID);
CREATE INDEX revisions_process_main_process_id_idx ON revisions_process USING hash (MAIN_PROCESS_ID);
CREATE INDEX revision_type_idx ON revisions_process (REVISION_TYPE);

CREATE TABLE coloring_process(
    PROCESS_ID SERIAL,
    MAIN_PROCESS_ID INTEGER UNIQUE REFERENCES processes(MAIN_PROCESS_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    COLORING_TYPE COLORING_TYPES NOT NULL,
    CONSTRAINT COLORING_PROCESS_PK PRIMARY KEY(PROCESS_ID)
);
CREATE INDEX coloring_process_id_idx ON coloring_process USING hash (PROCESS_ID);
CREATE INDEX coloring_process_main_process_id_idx ON coloring_process USING hash (MAIN_PROCESS_ID);
CREATE INDEX coloring_type_idx ON coloring_process (COLORING_TYPE);

CREATE TABLE animation_process(
    PROCESS_ID SERIAL,
    MAIN_PROCESS_ID INTEGER UNIQUE REFERENCES processes(MAIN_PROCESS_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    FRAME_RATE INTEGER NOT NULL,
    ANIMATION_TECHNOLOGY VARCHAR(32) NOT NULL,
    CONSTRAINT ANIMATION_PROCESS_PK PRIMARY KEY(PROCESS_ID),
    CONSTRAINT ANIMATION_PROCESS_FRAME_RATE_CHECK CHECK(FRAME_RATE > 0)
);
CREATE INDEX animation_process_id_idx ON animation_process USING hash (PROCESS_ID);
CREATE INDEX animation_process_main_process_id_idx ON animation_process USING hash (MAIN_PROCESS_ID);
CREATE INDEX animation_technology_idx ON animation_process (ANIMATION_TECHNOLOGY);

CREATE TABLE adding_effect_process(
    PROCESS_ID SERIAL,
    MAIN_PROCESS_ID INTEGER UNIQUE REFERENCES processes(MAIN_PROCESS_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    EFFECT_LEVEL EFFECT_LEVELS NOT NULL,
    CONSTRAINT ADDING_EFFECT_PROCESS_PK PRIMARY KEY(PROCESS_ID)
);
CREATE INDEX adding_effect_process_id_idx ON adding_effect_process USING hash (PROCESS_ID);
CREATE INDEX adding_effect_process_main_process_id_idx ON adding_effect_process USING hash (MAIN_PROCESS_ID);
CREATE INDEX effect_level_idx ON adding_effect_process (EFFECT_LEVEL);

CREATE TABLE location_drawing_process(
    PROCESS_ID SERIAL,
    MAIN_PROCESS_ID INTEGER UNIQUE REFERENCES processes(MAIN_PROCESS_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    CONSTRAINT LOCATION_DRAWING_PROCESS_PK PRIMARY KEY(PROCESS_ID)
);
CREATE INDEX location_drawing_process_id_idx ON location_drawing_process USING hash (PROCESS_ID);
CREATE INDEX location_drawing_process_main_process_id_idx ON location_drawing_process USING hash (MAIN_PROCESS_ID);

CREATE TABLE battle_drawing_process(
    PROCESS_ID SERIAL,
    MAIN_PROCESS_ID INTEGER UNIQUE REFERENCES processes(MAIN_PROCESS_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    CONSTRAINT BATTLE_DRAWING_PROCESS_PK PRIMARY KEY(PROCESS_ID)
);
CREATE INDEX battle_drawing_process_id_idx ON battle_drawing_process USING hash (PROCESS_ID);
CREATE INDEX battle_drawing_process_main_process_id_idx ON battle_drawing_process USING hash (MAIN_PROCESS_ID);

CREATE TABLE character_drawing_process(
    PROCESS_ID SERIAL,
    MAIN_PROCESS_ID INTEGER UNIQUE REFERENCES processes(MAIN_PROCESS_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    CONSTRAINT CHARACTER_DRAWING_PROCESS_PK PRIMARY KEY(PROCESS_ID)
);
CREATE INDEX character_drawing_process_id_idx ON character_drawing_process USING hash (PROCESS_ID);
CREATE INDEX character_drawing_process_main_process_id_idx ON character_drawing_process USING hash (MAIN_PROCESS_ID);

CREATE TABLE character_select_process(
    PROCESS_ID SERIAL,
    MAIN_PROCESS_ID INTEGER UNIQUE REFERENCES processes(MAIN_PROCESS_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    CONSTRAINT CHARACTER_SELECT_PROCESS_PK PRIMARY KEY(PROCESS_ID)
);
CREATE INDEX character_select_process_id_idx ON character_select_process USING hash (PROCESS_ID);
CREATE INDEX character_select_process_main_process_id_idx ON character_select_process USING hash (MAIN_PROCESS_ID);

CREATE TABLE voice_acting_process(
    PROCESS_ID SERIAL,
    MAIN_PROCESS_ID INTEGER UNIQUE REFERENCES processes(MAIN_PROCESS_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    VOICE_ACTING_TYPE VOICE_ACTING_TYPES NOT NULL,
    CONSTRAINT VOICE_ACTING_PROCESS_PK PRIMARY KEY(PROCESS_ID)
);
CREATE INDEX voice_acting_process_id_idx ON voice_acting_process USING hash (PROCESS_ID);
CREATE INDEX voice_acting_process_main_process_id_idx ON voice_acting_process USING hash (MAIN_PROCESS_ID);
CREATE INDEX voice_acting_type ON voice_acting_process (VOICE_ACTING_TYPE);

CREATE TABLE ability_description_process(
    PROCESS_ID SERIAL,
    MAIN_PROCESS_ID INTEGER UNIQUE REFERENCES processes(MAIN_PROCESS_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    CONSTRAINT ABILITY_DESCRIPTION_PROCESS_PK PRIMARY KEY(PROCESS_ID)
);
CREATE INDEX ability_description_process_id_idx ON ability_description_process USING hash (PROCESS_ID);
CREATE INDEX ability_description_process_main_process_id_idx ON ability_description_process USING hash (MAIN_PROCESS_ID);

CREATE TABLE character_description_process(
    PROCESS_ID SERIAL,
    MAIN_PROCESS_ID INTEGER UNIQUE REFERENCES processes(MAIN_PROCESS_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    CONSTRAINT CHARACTER_DESCRIPTION_PROCESS_PK PRIMARY KEY(PROCESS_ID)
);
CREATE INDEX character_description_process_id_idx ON character_description_process USING hash (PROCESS_ID);
CREATE INDEX character_description_process_main_process_id_idx ON character_description_process USING hash (MAIN_PROCESS_ID);

CREATE TABLE location_description_process(
    PROCESS_ID SERIAL,
    MAIN_PROCESS_ID INTEGER UNIQUE REFERENCES processes(MAIN_PROCESS_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    CONSTRAINT LOCATION_DESCRIPTION_PROCESS_PK PRIMARY KEY(PROCESS_ID)
);
CREATE INDEX location_description_process_id_idx ON location_description_process USING hash (PROCESS_ID);
CREATE INDEX location_description_process_main_process_id_idx ON location_description_process USING hash (MAIN_PROCESS_ID);

CREATE TABLE battle_description_process(
    PROCESS_ID SERIAL,
    MAIN_PROCESS_ID INTEGER UNIQUE REFERENCES processes(MAIN_PROCESS_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    CONSTRAINT BATTLE_DESCRIPTION_PROCESS_PK PRIMARY KEY(PROCESS_ID)
);
CREATE INDEX battle_description_process_id_idx ON battle_description_process USING hash (PROCESS_ID);
CREATE INDEX battle_description_process_main_process_id_idx ON battle_description_process USING hash (MAIN_PROCESS_ID);

CREATE TABLE plot_process(
    PROCESS_ID SERIAL,
    MAIN_PROCESS_ID INTEGER UNIQUE REFERENCES processes(MAIN_PROCESS_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    CONSTRAINT PLOT_PROCESS_PK PRIMARY KEY(PROCESS_ID)
);
CREATE INDEX plot_process_id_idx ON plot_process USING hash (PROCESS_ID);
CREATE INDEX plot_process_main_process_id_idx ON plot_process USING hash (MAIN_PROCESS_ID);

/*
*создание сущности артефакт
*/
CREATE TABLE artifacts(
    ARTIFACT_ID SERIAL,
    MAIN_WORKER_ID INTEGER REFERENCES workers(MAIN_WORKER_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    ARTIFACT_TYPE ARTIFACT_TYPES NOT NULL,
    SIZE INTEGER NOT NULL,
    UPLOAD_DATE TIMESTAMP NOT NULL,
    CONSTRAINT ARTIFACTS_PK PRIMARY KEY(ARTIFACT_ID),
    CONSTRAINT ARTIFACTS_SIZE_CHECK CHECK(SIZE >= 0)
);
CREATE INDEX artifact_id_idx ON artifacts USING hash (ARTIFACT_ID);
CREATE INDEX artifacts_main_worker_id_idx ON artifacts USING hash (MAIN_WORKER_ID);
CREATE INDEX artifact_type_idx ON artifacts (ARTIFACT_TYPE);
CREATE INDEX upload_date_idx ON artifacts (UPLOAD_DATE DESC);
CREATE INDEX artifact_type_upload_date_idx ON artifacts (ARTIFACT_TYPE, UPLOAD_DATE);

/*
*создание основных стержневых сущностей
*/
CREATE TABLE plot(
    PLOT_ID SERIAL,
    PLOT_PROCESS INTEGER REFERENCES plot_process(PROCESS_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    PLOT_NAME VARCHAR(32) NOT NULL,
    PAGES_NUMBER INTEGER NOT NULL,
    PLOT_TYPE PLOT_TYPES NOT NULL,
    DESCRIPTION TEXT NOT NULL,
    NARRATIVE_PERIOD INTERVAL NOT NULL,
    CONSTRAINT PLOT_PK PRIMARY KEY(PLOT_ID),
    CONSTRAINT PLOT_PAGES_NUMBER_CHECK CHECK(PAGES_NUMBER > 0)
);
CREATE INDEX plot_id_idx ON plot USING hash (PLOT_ID);
CREATE INDEX plot_process_idx ON plot USING hash (PLOT_PROCESS);
CREATE INDEX plot_name_idx ON plot USING hash (PLOT_NAME);

CREATE TABLE events(
    EVENT_ID SERIAL,
    EVENT_NAME VARCHAR(32) NOT NULL,
    DESCRIPTION TEXT NOT NULL,
    IMPORTANCE_LEVEL INTEGER NOT NULL,
    CONSTRAINT EVENTS_PK PRIMARY KEY(EVENT_ID),
    CONSTRAINT EVENTS_IMPORTANCE_LEVEL_CHECK CHECK(IMPORTANCE_LEVEL BETWEEN 0 AND 10)
);
CREATE INDEX event_id_idx ON events USING hash (EVENT_ID);
CREATE INDEX event_name_idx ON events USING hash (EVENT_NAME);

CREATE TABLE locations(
    LOCATION_ID SERIAL,
    DESCRIPTION_ID INTEGER REFERENCES location_description_process(PROCESS_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    DRAWING_ID INTEGER REFERENCES location_drawing_process(PROCESS_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    LOCATION_NAME VARCHAR(32) NOT NULL,
    AREA INTEGER NOT NULL,
    LOCATION_TYPE LOCATION_TYPES NOT NULL,
    FOR_BATTLE BOOLEAN NOT NULL,
    CONSTRAINT LOCATIONS_PK PRIMARY KEY(LOCATION_ID),
    CONSTRAINT LOCATIONS_AREA_CHECK CHECK(AREA > 0)
);
CREATE INDEX location_id_idx ON locations USING hash (LOCATION_ID);
CREATE INDEX location_description_id_idx ON locations USING hash (DESCRIPTION_ID);
CREATE INDEX location_drawing_id_idx ON locations USING hash (DRAWING_ID);
CREATE INDEX location_name_idx ON locations USING hash (LOCATION_NAME);

CREATE TABLE battle(
    BATTLE_ID SERIAL,
    DESCRIPTION_ID INTEGER REFERENCES battle_description_process(PROCESS_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    DRAWING_ID INTEGER REFERENCES battle_drawing_process(PROCESS_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    BATTLE_NAME VARCHAR(32) NOT NULL,
    DURATION NUMERIC(5,3) NOT NULL,
    CONSTRAINT BATTLE_PK PRIMARY KEY(BATTLE_ID)
);
CREATE INDEX battle_id ON battle USING hash (BATTLE_ID);
CREATE INDEX battle_description_id_idx ON battle USING hash (DESCRIPTION_ID);
CREATE INDEX battle_drawing_id_idx ON battle USING hash (DRAWING_ID);
CREATE INDEX battle_name_idx ON battle USING hash (BATTLE_NAME);

CREATE TABLE abilities(
    ABILITY_ID SERIAL,
    DESCRIPTION_ID INTEGER REFERENCES ability_description_process(PROCESS_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    ABILITY_NAME VARCHAR(32) NOT NULL,
    DESCRIPTION TEXT NOT NULL,
    ABILITY_TYPE ABILITY_TYPES NOT NULL,
    COMPLEXITY_LEVEL INTEGER NOT NULL,
    CONSTRAINT ABILITIES_PK PRIMARY KEY(ABILITY_ID),
    CONSTRAINT ABILITIES_COMPLEXITY_LEVEL_CHECK CHECK(COMPLEXITY_LEVEL BETWEEN 0 AND 10)
);
CREATE INDEX ability_id_idx ON abilities USING hash (ABILITY_ID);
CREATE INDEX ability_description_id_idx ON abilities USING hash (DESCRIPTION_ID);
CREATE INDEX ability_name_idx ON abilities USING hash (ABILITY_NAME);

CREATE TABLE character(
    CHARACTER_ID SERIAL,
    VOICE_ACTING_ID INTEGER REFERENCES voice_acting_process(PROCESS_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    SELECTION_ID INTEGER REFERENCES character_select_process(PROCESS_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    DRAWING_ID INTEGER REFERENCES character_drawing_process(PROCESS_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    DESCRIPTION_ID INTEGER REFERENCES character_description_process(PROCESS_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    CHARACTER_NAME VARCHAR(32) NOT NULL,
    GENDER VARCHAR(32) NOT NULL,
    PROTAGONIST BOOLEAN NOT NULL,
    POSITIVE BOOLEAN NOT NULL,
    AGE INTEGER NOT NULL,
    BIRTH_DATE DATE,
    CONSTRAINT CHARACTER_PK PRIMARY KEY(CHARACTER_ID),
    CONSTRAINT CHARACTER_AGE_CHECK CHECK(AGE > 0)
);
CREATE INDEX character_id_idx ON character USING hash (CHARACTER_ID);
CREATE INDEX character_voice_acting_id_idx ON character USING hash (VOICE_ACTING_ID);
CREATE INDEX character_selection_id_idx ON character USING hash (SELECTION_ID);
CREATE INDEX character_drawing_id_idx ON character USING hash (DRAWING_ID);
CREATE INDEX character_description_id_idx ON character USING hash (DESCRIPTION_ID);
CREATE INDEX character_name_idx ON character USING hash (CHARACTER_NAME);

/*
*создание ассоциаций между процессами
*/
CREATE TABLE revision_storyboarding(
    REVISION_ID INTEGER REFERENCES revisions_process(PROCESS_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    PROCESS_ID INTEGER REFERENCES storyboard_process(PROCESS_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    CONSTRAINT REVISION_STORYBOARDING_PK PRIMARY KEY(REVISION_ID, PROCESS_ID)
);
CREATE INDEX revision_storyboarding_revision_id_idx ON revision_storyboarding USING hash (REVISION_ID);
CREATE INDEX revision_storyboarding_process_id_idx ON revision_storyboarding USING hash (PROCESS_ID);

CREATE TABLE revision_adding_sound(
    REVISION_ID INTEGER REFERENCES revisions_process(PROCESS_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    PROCESS_ID INTEGER REFERENCES adding_sound_process(PROCESS_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    CONSTRAINT REVISION_ADDING_SOUND_PK PRIMARY KEY(REVISION_ID, PROCESS_ID)
);
CREATE INDEX revision_adding_sound_revision_id_idx ON revision_adding_sound USING hash (REVISION_ID);
CREATE INDEX revision_adding_sound_process_id_idx ON revision_adding_sound USING hash (PROCESS_ID);

CREATE TABLE revision_smoothing(
    REVISION_ID INTEGER REFERENCES revisions_process(PROCESS_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    PROCESS_ID INTEGER REFERENCES smoothing_process(PROCESS_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    CONSTRAINT REVISION_SMOOTHING_PK PRIMARY KEY(REVISION_ID, PROCESS_ID)
);
CREATE INDEX revision_smoothing_revision_id_idx ON revision_smoothing USING hash (REVISION_ID);
CREATE INDEX revision_smoothing_process_id_idx ON revision_smoothing USING hash (PROCESS_ID);

CREATE TABLE revision_adding_effects(
    REVISION_ID INTEGER REFERENCES revisions_process(PROCESS_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    PROCESS_ID INTEGER REFERENCES adding_effect_process(PROCESS_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    CONSTRAINT REVISION_ADDING_EFFECTS_PK PRIMARY KEY(REVISION_ID, PROCESS_ID)
);
CREATE INDEX revision_adding_effects_revision_id_idx ON revision_adding_effects USING hash (REVISION_ID);
CREATE INDEX revision_adding_effects_process_id_idx ON revision_adding_effects USING hash (PROCESS_ID);

CREATE TABLE revision_animation(
    REVISION_ID INTEGER REFERENCES revisions_process(PROCESS_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    PROCESS_ID INTEGER REFERENCES animation_process(PROCESS_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    CONSTRAINT REVISION_ANIMATION_PK PRIMARY KEY(REVISION_ID, PROCESS_ID)
);
CREATE INDEX revision_animation_revision_id_idx ON revision_animation USING hash (REVISION_ID);
CREATE INDEX revision_animation_process_id_idx ON revision_animation USING hash (PROCESS_ID);

CREATE TABLE revision_coloring(
    REVISION_ID INTEGER REFERENCES revisions_process(PROCESS_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    PROCESS_ID INTEGER REFERENCES coloring_process(PROCESS_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    CONSTRAINT REVISION_COLORING_PK PRIMARY KEY(REVISION_ID, PROCESS_ID)
);
CREATE INDEX revision_coloring_revision_id_idx ON revision_coloring USING hash (REVISION_ID);
CREATE INDEX revision_coloring_process_id_idx ON revision_coloring USING hash (PROCESS_ID);

/*
*создание ассоциаций между процессами и выполняющими их работниками
*/
CREATE TABLE artist_storyboard_process(
    PROCESS_ID INTEGER REFERENCES storyboard_process(PROCESS_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    WORKER_ID INTEGER REFERENCES storyboard_artists(WORKER_ID) ON UPDATE CASCADE ON  DELETE CASCADE,
    CONSTRAINT ARTIST_STORYBOARD_PROCESS_PK PRIMARY KEY(PROCESS_ID, WORKER_ID)
);
CREATE INDEX artist_storyboard_process_id_idx ON artist_storyboard_process USING hash (PROCESS_ID);
CREATE INDEX artist_storyboard_process_worker_id_idx ON artist_storyboard_process USING hash (WORKER_ID);

CREATE TABLE producer_advertising_process(
    PROCESS_ID INTEGER REFERENCES advertising_process(PROCESS_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    WORKER_ID INTEGER REFERENCES producers(WORKER_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    CONSTRAINT PRODUCER_ADVERTISING_PROCESS_PK PRIMARY KEY(PROCESS_ID, WORKER_ID)
);
CREATE INDEX producer_advertising_process_id_idx ON producer_advertising_process USING hash (PROCESS_ID);
CREATE INDEX producer_advertising_process_worker_id_idx ON producer_advertising_process USING hash (WORKER_ID);

CREATE TABLE audio_adding_process(
    PROCESS_ID INTEGER REFERENCES adding_sound_process(PROCESS_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    WORKER_ID INTEGER REFERENCES audio_specialist(WORKER_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    CONSTRAINT AUDIO_ADDING_PROCESS_PK PRIMARY KEY(PROCESS_ID, WORKER_ID)
);
CREATE INDEX audio_adding_process_id_idx ON audio_adding_process USING hash (PROCESS_ID);
CREATE INDEX audio_adding_process_worker_id_idx ON audio_adding_process USING hash (WORKER_ID);

CREATE TABLE digitizers_digitization_process(
    PROCESS_ID INTEGER REFERENCES digitization_process(PROCESS_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    WORKER_ID INTEGER REFERENCES digitizers(WORKER_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    CONSTRAINT DIGITIZERS_DIGITIZATION_PROCESS_PK PRIMARY KEY(PROCESS_ID, WORKER_ID)
);
CREATE INDEX digitizers_digitization_process_id_idx ON digitizers_digitization_process USING hash (PROCESS_ID);
CREATE INDEX digitizers_digitization_process_worker_id_idx ON digitizers_digitization_process USING hash (WORKER_ID);

CREATE TABLE smoother_smoothing_process(
    PROCESS_ID INTEGER REFERENCES smoothing_process(PROCESS_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    WORKER_ID INTEGER REFERENCES smoothing_specialist(WORKER_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    CONSTRAINT SMOOTHER_SMOOTHING_PROCESS_PK PRIMARY KEY(PROCESS_ID, WORKER_ID)
);
CREATE INDEX smoother_smoothing_process_id_idx ON smoother_smoothing_process USING hash (PROCESS_ID);
CREATE INDEX smoother_smoothing_process_worker_id_idx ON smoother_smoothing_process USING hash (WORKER_ID);

CREATE TABLE art_director_revision_process(
    PROCESS_ID INTEGER REFERENCES revisions_process(PROCESS_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    WORKER_ID INTEGER REFERENCES art_director(WORKER_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    CONSTRAINT ART_DIRECTOR_REVISION_PROCESS_PK PRIMARY KEY(PROCESS_ID, WORKER_ID)
);
CREATE INDEX art_director_revision_process_id_idx ON art_director_revision_process USING hash (PROCESS_ID);
CREATE INDEX art_director_revision_worker_id_idx ON art_director_revision_process USING hash (WORKER_ID);

CREATE TABLE artist_coloring_process(
    PROCESS_ID INTEGER REFERENCES coloring_process(PROCESS_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    WORKER_ID INTEGER REFERENCES artists(WORKER_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    CONSTRAINT ARTIST_COLORING_PROCESS_PK PRIMARY KEY(PROCESS_ID, WORKER_ID)
);
CREATE INDEX artist_coloring_process_id_idx ON artist_coloring_process USING hash (PROCESS_ID);
CREATE INDEX artist_coloring_process_worker_id_idx ON artist_coloring_process USING hash (WORKER_ID);

CREATE TABLE artist_animation_process(
    PROCESS_ID INTEGER REFERENCES animation_process(PROCESS_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    WORKER_ID INTEGER REFERENCES artists(WORKER_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    CONSTRAINT ARTIST_ANIMATION_PROCESS_PK PRIMARY KEY(PROCESS_ID, WORKER_ID)
);
CREATE INDEX artist_animation_process_id_idx ON artist_animation_process USING hash (PROCESS_ID);
CREATE INDEX artist_animation_process_worker_id_idx ON artist_animation_process USING hash (WORKER_ID);

CREATE TABLE artist_effects_process(
    PROCESS_ID INTEGER REFERENCES adding_effect_process(PROCESS_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    WORKER_ID INTEGER REFERENCES artists(WORKER_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    CONSTRAINT ARTIST_EFFECTS_PROCESS_PK PRIMARY KEY(PROCESS_ID, WORKER_ID)
);
CREATE INDEX artist_effects_process_id_idx ON artist_effects_process USING hash (PROCESS_ID);
CREATE INDEX artist_effects_process_worker_id_idx ON artist_effects_process USING hash (WORKER_ID);

CREATE TABLE artist_location_drawing_process(
    PROCESS_ID INTEGER REFERENCES location_drawing_process(PROCESS_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    WORKER_ID INTEGER REFERENCES artists(WORKER_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    CONSTRAINT ARTIST_LOCATION_DRAWING_PROCESS_PK PRIMARY KEY(PROCESS_ID, WORKER_ID)
);
CREATE INDEX artist_location_drawing_process_id_idx ON artist_location_drawing_process USING hash (PROCESS_ID);
CREATE INDEX artist_location_drawing_process_worker_id_idx ON artist_location_drawing_process USING hash (WORKER_ID);

CREATE TABLE artist_battle_drawing_process(
    PROCESS_ID INTEGER REFERENCES battle_drawing_process(PROCESS_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    WORKER_ID INTEGER REFERENCES artists(WORKER_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    CONSTRAINT ARTIST_BATTLE_DRAWING_PROCESS_PK PRIMARY KEY(PROCESS_ID, WORKER_ID)
);
CREATE INDEX artist_battle_drawing_process_id_idx ON artist_battle_drawing_process USING hash (PROCESS_ID);
CREATE INDEX artist_battle_drawing_process_worker_id_idx ON artist_battle_drawing_process USING hash (WORKER_ID);

CREATE TABLE artist_character_drawing_process(
    PROCESS_ID INTEGER REFERENCES character_drawing_process(PROCESS_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    WORKER_ID INTEGER REFERENCES artists(WORKER_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    CONSTRAINT ARTIST_CHARACTER_DRAWING_PROCESS_PK PRIMARY KEY(PROCESS_ID, WORKER_ID)
);
CREATE INDEX artist_character_drawing_process_id_idx ON artist_character_drawing_process USING hash (PROCESS_ID);
CREATE INDEX artist_character_drawing_process_worker_id_idx ON artist_character_drawing_process USING hash (WORKER_ID);

CREATE TABLE editors_character_process(
    PROCESS_ID INTEGER REFERENCES character_select_process(PROCESS_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    WORKER_ID INTEGER REFERENCES editors(WORKER_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    CONSTRAINT EDITORS_CHARACTER_PROCESS_PK PRIMARY KEY(PROCESS_ID, WORKER_ID)
);
CREATE INDEX editors_character_process_id_idx ON editors_character_process USING hash (PROCESS_ID);
CREATE INDEX editors_character_process_worker_id_idx ON editors_character_process USING hash (WORKER_ID);

CREATE TABLE recorder_voice_acting_process(
    PROCESS_ID INTEGER REFERENCES voice_acting_process(PROCESS_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    WORKER_ID INTEGER REFERENCES recording_actors(WORKER_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    CONSTRAINT RECORDER_VOICE_ACTING_PROCESS_PK PRIMARY KEY(PROCESS_ID, WORKER_ID)
);
CREATE INDEX recorder_voice_acting_process_id_idx ON recorder_voice_acting_process USING hash (PROCESS_ID);
CREATE INDEX recorder_voice_acting_process_worker_id_idx ON recorder_voice_acting_process USING hash (WORKER_ID);

CREATE TABLE designer_ability_process(
    PROCESS_ID INTEGER REFERENCES ability_description_process(PROCESS_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    WORKER_ID INTEGER REFERENCES roles_designers(WORKER_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    CONSTRAINT DESIGNER_ABILITY_PROCESS_PK PRIMARY KEY(PROCESS_ID, WORKER_ID)
);
CREATE INDEX designer_ability_process_id_idx ON designer_ability_process USING hash (PROCESS_ID);
CREATE INDEX designer_ability_process_worker_id_idx ON designer_ability_process USING hash (WORKER_ID);

CREATE TABLE designer_character_process(
    PROCESS_ID INTEGER REFERENCES character_description_process(PROCESS_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    WORKER_ID INTEGER REFERENCES roles_designers(WORKER_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    CONSTRAINT DESIGNER_CHARACTER_PROCESS_PK PRIMARY KEY(PROCESS_ID, WORKER_ID)
);
CREATE INDEX designer_character_process_id_idx ON designer_character_process USING hash (PROCESS_ID);
CREATE INDEX designer_character_process_worker_id_idx ON designer_character_process USING hash (WORKER_ID);

CREATE TABLE regisseur_location_process(
    PROCESS_ID INTEGER REFERENCES location_description_process(PROCESS_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    WORKER_ID INTEGER REFERENCES regisseurs(WORKER_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    CONSTRAINT REGISSEUR_LOCATION_PROCESS_PK PRIMARY KEY(PROCESS_ID, WORKER_ID)
);
CREATE INDEX regisseur_location_process_id_idx ON regisseur_location_process USING hash (PROCESS_ID);
CREATE INDEX regisseur_location_process_worker_id_idx ON regisseur_location_process USING hash (WORKER_ID);

CREATE TABLE screenwriter_battle_process(
    PROCESS_ID INTEGER REFERENCES battle_description_process(PROCESS_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    WORKER_ID INTEGER REFERENCES screenwriters(WORKER_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    CONSTRAINT SCREENWRITER_BATTLE_PROCESS_Pk PRIMARY KEY(PROCESS_ID, WORKER_ID)
);
CREATE INDEX screenwriter_battle_process_id_idx ON screenwriter_battle_process USING hash (PROCESS_ID);
CREATE INDEX screenwriter_battle_process_worker_id_idx ON screenwriter_battle_process USING hash (WORKER_ID);

CREATE TABLE regisseurs_plot_process(
    PROCESS_ID INTEGER REFERENCES plot_process(PROCESS_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    WORKER_ID INTEGER REFERENCES regisseurs(WORKER_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    CONSTRAINT REGISSEURS_PLOT_PROCESS_PK PRIMARY KEY(PROCESS_ID, WORKER_ID)
);
CREATE INDEX regisseurs_plot_process_id_idx ON regisseurs_plot_process USING hash (PROCESS_ID);
CREATE INDEX regisseurs_plot_process_worker_id_idx ON regisseurs_plot_process USING hash (WORKER_ID);

CREATE TABLE screenwriter_plot_process(
    PROCESS_ID INTEGER REFERENCES plot_process(PROCESS_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    WORKER_ID INTEGER REFERENCES screenwriters(WORKER_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    CONSTRAINT SCREENWRITER_PLOT_PROCESS_PK PRIMARY KEY(PROCESS_ID, WORKER_ID)
);
CREATE INDEX screenwriter_plot_process_id_idx ON screenwriter_plot_process USING hash (PROCESS_ID);
CREATE INDEX screenwriter_plot_process_worker_id_idx ON screenwriter_plot_process USING hash (WORKER_ID);

/*
*создание ассоциации между процессами и артифактами
*/
CREATE TABLE process_artifact(
    MAIN_PROCESS_ID INTEGER REFERENCES processes(MAIN_PROCESS_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    ARTIFACT_ID INTEGER REFERENCES artifacts(ARTIFACT_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    CONSTRAINT PROCESS_ARTIFACT_PK PRIMARY KEY(MAIN_PROCESS_ID, ARTIFACT_ID)
);
CREATE INDEX process_artifact_main_process_id_idx ON process_artifact USING hash (MAIN_PROCESS_ID);
CREATE INDEX process_artifact_artifact_id_idx ON process_artifact USING hash (ARTIFACT_ID);


/*
*создание ассоциаций между основными стержневыми сущностями
*/
CREATE TABLE events_plots(
    EVENT_ID INTEGER REFERENCES events(EVENT_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    PLOT_ID INTEGER REFERENCES plot(PLOT_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    CONSTRAINT EVENTS_PLOTS_PK PRIMARY KEY(EVENT_ID, PLOT_ID)
);
CREATE INDEX events_plots_event_id_idx ON events_plots USING hash (EVENT_ID);
CREATE INDEX events_plots_plot_id_idx ON events_plots USING hash (PLOT_ID);

CREATE TABLE event_location(
    EVENT_ID INTEGER REFERENCES events(EVENT_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    LOCATION_ID INTEGER REFERENCES locations(LOCATION_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    CONSTRAINT EVENT_LOCATION_PK PRIMARY KEY(EVENT_ID, LOCATION_ID)
);
CREATE INDEX event_location_event_id_idx ON event_location USING hash (EVENT_ID);
CREATE INDEX event_location_location_id_idx ON event_location USING hash (LOCATION_ID);

CREATE TABLE events_characters(
    EVENT_ID INTEGER REFERENCES events(EVENT_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    CHARACTER_ID INTEGER REFERENCES character(CHARACTER_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    CONSTRAINT EVENTS_CHARACTERS_PK PRIMARY KEY(EVENT_ID, CHARACTER_ID)
);
CREATE INDEX events_characters_event_id_idx ON events_characters USING hash (EVENT_ID);
CREATE INDEX events_characters_character_id_idx ON events_characters USING hash (CHARACTER_ID);

CREATE TABLE battle_location(
    LOCATION_ID INTEGER REFERENCES locations(LOCATION_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    BATTLE_ID INTEGER REFERENCES battle(BATTLE_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    CONSTRAINT BATTLE_LOCATION_PK PRIMARY KEY(BATTLE_ID, LOCATION_ID)
);
CREATE INDEX battle_location_location_id_idx ON battle_location USING hash (LOCATION_ID);
CREATE INDEX battle_location_battle_id_idx ON battle_location USING hash (BATTLE_ID);

CREATE TABLE battle_abilities(
    BATTLE_ID INTEGER REFERENCES battle(BATTLE_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    ABILITY_ID INTEGER REFERENCES abilities(ABILITY_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    CONSTRAINT BATTLE_ABILITIES_PK PRIMARY KEY(BATTLE_ID, ABILITY_ID)
);
CREATE INDEX battle_abilities_battle_id_idx ON battle_abilities USING hash (BATTLE_ID);
CREATE INDEX battle_abilities_ability_id_idx ON battle_abilities USING hash (ABILITY_ID);

CREATE TABLE battle_characters(
    BATTLE_ID INTEGER REFERENCES battle(BATTLE_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    CHARACTER_ID INTEGER REFERENCES character(CHARACTER_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    CONSTRAINT BATTLE_CHARACTERS_PK PRIMARY KEY(BATTLE_ID, CHARACTER_ID)
);
CREATE INDEX battle_characters_battle_id_idx ON battle_characters USING hash (BATTLE_ID);
CREATE INDEX battle_characters_character_id_idx ON battle_characters USING hash (CHARACTER_ID);

CREATE TABLE characters_abilities(
    CHARACTER_ID INTEGER REFERENCES character(CHARACTER_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    ABILITY_ID INTEGER REFERENCES abilities(ABILITY_ID) ON UPDATE CASCADE ON DELETE CASCADE,
    CONSTRAINT CHARACTERS_ABILITIES_PK PRIMARY KEY(CHARACTER_ID, ABILITY_ID)
);
CREATE INDEX characters_abilities_character_id_idx ON characters_abilities USING hash (CHARACTER_ID);
CREATE INDEX characters_abilities_ability_id_idx ON characters_abilities USING hash (ABILITY_ID);

/*
*табличка для логирования инфы о триггерах
*/
CREATE TABLE trigger_info(
    ID SERIAL PRIMARY KEY,
    TG_OP TEXT NOT NULL,
    TG_RELNAME VARCHAR(32) NOT NULL,
    TG_NAME VARCHAR(32) NOT NULL,
    CREATION_TIME TIMESTAMP WITH TIME ZONE NOT NULL
);

/*
*создание триггеров и триггерных функций
*/
CREATE OR REPLACE FUNCTION check_if_battle() RETURNS trigger AS
$body$
DECLARE 
    is_for_battle BOOLEAN;
BEGIN
    SELECT l.FOR_BATTLE INTO is_for_battle FROM locations AS l WHERE l.LOCATION_ID = NEW.LOCATION_ID;
    IF is_for_battle IS TRUE THEN
        INSERT INTO trigger_info(TG_OP, TG_RELNAME, TG_NAME, CREATION_TIME) VALUES(TG_OP, TG_RELNAME, TG_NAME, NOW());
        RETURN NEW;
    ELSE
        RETURN NULL;
    END IF;
END
$body$ LANGUAGE plpgsql VOLATILE;
CREATE TRIGGER is_battle_location BEFORE INSERT OR UPDATE ON battle_location FOR EACH ROW EXECUTE PROCEDURE check_if_battle();

CREATE OR REPLACE FUNCTION check_if_character_artist() RETURNS trigger AS
$body$
DECLARE
    artist_type ARTIST_TYPES;
BEGIN
    SELECT a.ARTIST_TYPE INTO artist_type FROM artists AS a WHERE a.WORKER_ID = NEW.WORKER_ID;
    IF artist_type = 'character artist' THEN
        INSERT INTO trigger_info(TG_OP, TG_RELNAME, TG_NAME, CREATION_TIME) VALUES(TG_OP, TG_RELNAME, TG_NAME, NOW());
        RETURN NEW;
    ELSE
        RETURN NULL;
    END IF;
END
$body$ LANGUAGE plpgsql VOLATILE;
CREATE TRIGGER is_character_artist BEFORE INSERT OR UPDATE ON artist_character_drawing_process FOR EACH ROW EXECUTE PROCEDURE check_if_character_artist();

CREATE OR REPLACE FUNCTION check_if_battle_artist() RETURNS trigger AS
$body$
DECLARE
    artist_type ARTIST_TYPES;
BEGIN
    SELECT a.ARTIST_TYPE INTO artist_type FROM artists AS a WHERE a.WORKER_ID = NEW.WORKER_ID;
    IF artist_type = 'battle artist' THEN
        INSERT INTO trigger_info(TG_OP, TG_RELNAME, TG_NAME, CREATION_TIME) VALUES(TG_OP, TG_RELNAME, TG_NAME, NOW());
        RETURN NEW;
    ELSE
        RETURN NULL;
    END IF;
END
$body$ LANGUAGE plpgsql VOLATILE;
CREATE TRIGGER is_battle_artist BEFORE INSERT OR UPDATE ON artist_battle_drawing_process FOR EACH ROW EXECUTE PROCEDURE check_if_battle_artist();

CREATE OR REPLACE FUNCTION check_if_location_artist() RETURNS trigger AS
$body$
DECLARE
    artist_type ARTIST_TYPES;
BEGIN
    SELECT a.ARTIST_TYPE INTO artist_type FROM artists AS a WHERE a.WORKER_ID = NEW.WORKER_ID;
    IF artist_type = 'location artist' THEN
        INSERT INTO trigger_info(TG_OP, TG_RELNAME, TG_NAME, CREATION_TIME) VALUES(TG_OP, TG_RELNAME, TG_NAME, NOW());
        RETURN NEW;
    ELSE
        RETURN NULL;
    END IF;
END
$body$ LANGUAGE plpgsql VOLATILE;
CREATE TRIGGER is_location_artist BEFORE INSERT OR UPDATE ON artist_location_drawing_process FOR EACH ROW EXECUTE PROCEDURE check_if_location_artist();

CREATE OR REPLACE FUNCTION check_if_effect_artist() RETURNS trigger AS
$body$
DECLARE
    artist_type ARTIST_TYPES;
BEGIN
    SELECT a.ARTIST_TYPE INTO artist_type FROM artists AS a WHERE a.WORKER_ID = NEW.WORKER_ID;
    IF artist_type = 'effect artist' THEN
        INSERT INTO trigger_info(TG_OP, TG_RELNAME, TG_NAME, CREATION_TIME) VALUES(TG_OP, TG_RELNAME, TG_NAME, NOW());
        RETURN NEW;
    ELSE
        RETURN NULL;
    END IF;
END
$body$ LANGUAGE plpgsql VOLATILE;
CREATE TRIGGER is_effect_artist BEFORE INSERT OR UPDATE ON artist_effects_process FOR EACH ROW EXECUTE PROCEDURE check_if_effect_artist();

CREATE OR REPLACE FUNCTION check_if_animation_artist() RETURNS trigger AS
$body$
DECLARE
    artist_type ARTIST_TYPES;
BEGIN
    SELECT a.ARTIST_TYPE INTO artist_type FROM artists AS a WHERE a.WORKER_ID = NEW.WORKER_ID;
    IF artist_type = 'animation artist' THEN
        INSERT INTO trigger_info(TG_OP, TG_RELNAME, TG_NAME, CREATION_TIME) VALUES(TG_OP, TG_RELNAME, TG_NAME, NOW());
        RETURN NEW;
    ELSE
        RETURN NULL;
    END IF;
END
$body$ LANGUAGE plpgsql VOLATILE;
CREATE TRIGGER is_animation_artist BEFORE INSERT OR UPDATE ON artist_animation_process FOR EACH ROW EXECUTE PROCEDURE check_if_animation_artist();

CREATE OR REPLACE FUNCTION check_if_coloring_artist() RETURNS trigger AS
$body$
DECLARE
    artist_type ARTIST_TYPES;
BEGIN
    SELECT a.ARTIST_TYPE INTO artist_type FROM artists AS a WHERE a.WORKER_ID = NEW.WORKER_ID;
    IF artist_type = 'coloring artist' THEN
        INSERT INTO trigger_info(TG_OP, TG_RELNAME, TG_NAME, CREATION_TIME) VALUES(TG_OP, TG_RELNAME, TG_NAME, NOW());
        RETURN NEW;
    ELSE
        RETURN NULL;
    END IF;
END
$body$ LANGUAGE plpgsql VOLATILE;
CREATE TRIGGER is_coloring_artist BEFORE INSERT OR UPDATE ON artist_coloring_process FOR EACH ROW EXECUTE PROCEDURE check_if_coloring_artist();

/*
*создание функций для основных стержневых сущностей
*/
CREATE OR REPLACE FUNCTION get_locations_and_battles() RETURNS 
TABLE(
    LOCATION_ID INTEGER, 
    LOCATION_NAME VARCHAR, 
    BATTLE_NAME VARCHAR, 
    BATTLE_ID INTEGER) AS
$body$
BEGIN
    RETURN QUERY SELECT l.LOCATION_ID, l.LOCATION_NAME, b.BATTLE_NAME, b.BATTLE_ID FROM locations AS l 
    JOIN battle_location USING(LOCATION_ID) JOIN battle AS b USING(BATTLE_ID);
END
$body$
LANGUAGE plpgsql STABLE;

CREATE OR REPLACE FUNCTION get_abilities_in_battle() RETURNS 
TABLE(
    BATTLE_NAME VARCHAR, 
    ABILITY_NAME VARCHAR, 
    ABILITY_DESCRIPTION VARCHAR, 
    ABILITY_TYPE ABILITY_TYPES) AS
$body$
BEGIN
    RETURN QUERY SELECT b.BATTLE_NAME, a.ABILITY_NAME, a.DESCRIPTION, a.ABILITY_TYPE FROM battle AS b 
    JOIN battle_abilities USING(BATTLE_ID) JOIN abilities AS a USING(ABILITY_ID);
END
$body$
LANGUAGE plpgsql STABLE;

CREATE OR REPLACE FUNCTION get_character_ablilities(char_id INTEGER) RETURNS
TABLE(
    CHARACTER_NAME VARCHAR, 
    ABILITY_NAME VARCHAR, 
    ABILITY_DESCRIPTION TEXT, 
    ABILITY_TYPE ABILITY_TYPES, 
    COMPLEXITY_LEVEL INTEGER) AS
$body$
BEGIN
    RETURN QUERY SELECT c.CHARACTER_NAME, a.ABILITY_NAME, a.DESCRIPTION, a.ABILITY_TYPE, a.COMPLEXITY_LEVEL FROM character AS c 
    JOIN characters_abilities USING(CHARACTER_ID) JOIN abilities AS a USING(ABILITY_ID) WHERE c.CHARACTER_ID = char_id;
END
$body$ LANGUAGE plpgsql STABLE;

CREATE OR REPLACE FUNCTION get_battle_info(name VARCHAR, is_battle_name BOOLEAN) RETURNS 
TABLE(
    CHARACTER_NAME VARCHAR, 
    BATTLE_NAME VARCHAR, 
    BATTLE_DURATION NUMERIC, 
    ABILITY_NAME VARCHAR, 
    ABILITY_DESCRIPTION TEXT, 
    ABILITY_TYPE ABILITY_TYPES, 
    COMPLEXITY_LEVEL INTEGER) AS
$body$
DECLARE
    table_attribute TEXT;
    table_name TEXT;
BEGIN
    IF is_battle_name IS TRUE THEN
        table_name := 'b';
        table_attribute := 'BATTLE_NAME';
    ELSE
        table_name := 'c';
        table_attribute := 'CHARACTER_NAME';
    END IF;
    RETURN QUERY EXECUTE FORMAT 
    ('SELECT c.CHARACTER_NAME, b.BATTLE_NAME, b.DURATION, a.ABILITY_NAME, a.DESCRIPTION, a.ABILITY_TYPE, a.COMPLEXITY_LEVEL 
    FROM character AS c JOIN battle_characters USING(CHARACTER_ID) JOIN battle AS b USING(BATTLE_ID) 
    JOIN battle_abilities USING(BATTLE_ID) JOIN abilities AS a USING(ABILITY_ID) 
    JOIN battle_location USING(BATTLE_ID) JOIN locations USING(LOCATION_ID) WHERE %2$I.%1$I LIKE $1', 
    table_attribute, table_name) USING name;
END
$body$ LANGUAGE plpgsql STABLE;

/*
*создание функций для работников
*/
CREATE OR REPLACE FUNCTION get_storyboarder_info(storyboarder_id INTEGER) RETURNS 
TABLE(
    WORKER_ID INTEGER, 
    WORKER_NAME VARCHAR,
    WORKER_SECOND_NAME VARCHAR, 
    GENDER VARCHAR, 
    AGE INTEGER, 
    PLACE_OF_BIRTH TEXT) AS
$body$
BEGIN
    RETURN QUERY SELECT s.WORKER_ID, w.NAME, w.SECOND_NAME, w.GENDER, w.AGE, w.PLACE_OF_BIRTH FROM storyboard_artists AS s 
    JOIN workers AS w USING(MAIN_WORKER_ID) WHERE s.WORKER_ID = storyboarder_id;
END
$body$ LANGUAGE plpgsql STABLE;

CREATE OR REPLACE FUNCTION get_producer_info(producer_id INTEGER) RETURNS 
TABLE(
    WORKER_ID INTEGER, 
    WORKER_NAME VARCHAR,
    WORKER_SECOND_NAME VARCHAR, 
    GENDER VARCHAR, 
    AGE INTEGER, 
    PLACE_OF_BIRTH TEXT,
    ROLE PRODUCER_ROLES) AS
$body$
BEGIN
    RETURN QUERY SELECT p.WORKER_ID, w.NAME, w.SECOND_NAME, w.GENDER, w.AGE, w.PLACE_OF_BIRTH, p.ROLE FROM producers AS p 
    JOIN workers AS w USING(MAIN_WORKER_ID) WHERE p.WORKER_ID = producer_id;
END
$body$ LANGUAGE plpgsql STABLE;

CREATE OR REPLACE FUNCTION get_audio_specialist_info(audio_specialist_id INTEGER) RETURNS 
TABLE(
    WORKER_ID INTEGER, 
    WORKER_NAME VARCHAR,
    WORKER_SECOND_NAME VARCHAR, 
    GENDER VARCHAR, 
    AGE INTEGER, 
    PLACE_OF_BIRTH TEXT) AS
$body$
BEGIN
    RETURN QUERY SELECT a.WORKER_ID, w.NAME, w.SECOND_NAME, w.GENDER, w.AGE, w.PLACE_OF_BIRTH FROM audio_specialist AS a 
    JOIN workers AS w USING(MAIN_WORKER_ID) WHERE a.WORKER_ID = audio_specialist_id;
END
$body$ LANGUAGE plpgsql STABLE;

CREATE OR REPLACE FUNCTION get_digitizer_info(digitizer_id INTEGER) RETURNS 
TABLE(
    WORKER_ID INTEGER, 
    WORKER_NAME VARCHAR,
    WORKER_SECOND_NAME VARCHAR, 
    GENDER VARCHAR, 
    AGE INTEGER, 
    PLACE_OF_BIRTH TEXT) AS
$body$
BEGIN
    RETURN QUERY SELECT d.WORKER_ID, w.NAME, w.SECOND_NAME, w.GENDER, w.AGE, w.PLACE_OF_BIRTH FROM digitizers AS d 
    JOIN workers AS w USING(MAIN_WORKER_ID) WHERE d.WORKER_ID = digitizer_id;
END
$body$ LANGUAGE plpgsql STABLE;

CREATE OR REPLACE FUNCTION get_smoothing_specialist_info(smoothing_specialist_id INTEGER) RETURNS 
TABLE(
    WORKER_ID INTEGER, 
    WORKER_NAME VARCHAR,
    WORKER_SECOND_NAME VARCHAR, 
    GENDER VARCHAR, 
    AGE INTEGER, 
    PLACE_OF_BIRTH TEXT) AS
$body$
BEGIN
    RETURN QUERY SELECT s.WORKER_ID, w.NAME, w.SECOND_NAME, w.GENDER, w.AGE, w.PLACE_OF_BIRTH FROM smoothing_specialist AS s 
    JOIN workers AS w USING(MAIN_WORKER_ID) WHERE s.WORKER_ID = smoothing_specialist_id;
END
$body$ LANGUAGE plpgsql STABLE;

CREATE OR REPLACE FUNCTION get_art_director_info(art_director_id INTEGER) RETURNS 
TABLE(
    WORKER_ID INTEGER, 
    WORKER_NAME VARCHAR,
    WORKER_SECOND_NAME VARCHAR, 
    GENDER VARCHAR, 
    AGE INTEGER, 
    PLACE_OF_BIRTH TEXT) AS
$body$
BEGIN
    RETURN QUERY SELECT ad.WORKER_ID, w.NAME, w.SECOND_NAME, w.GENDER, w.AGE, w.PLACE_OF_BIRTH FROM art_director AS ad 
    JOIN workers AS w USING(MAIN_WORKER_ID) WHERE ad.WORKER_ID = art_director_id;
END
$body$ LANGUAGE plpgsql STABLE;

CREATE OR REPLACE FUNCTION get_screenwriter_info(screenwriter_id INTEGER) RETURNS 
TABLE(
    WORKER_ID INTEGER, 
    WORKER_NAME VARCHAR,
    WORKER_SECOND_NAME VARCHAR, 
    GENDER VARCHAR, 
    AGE INTEGER, 
    PLACE_OF_BIRTH TEXT,
    FILMS_NUMBER INTEGER,
    GENRES VARCHAR[]) AS
$body$
BEGIN
    RETURN QUERY 
    SELECT sw.WORKER_ID, w.NAME, w.SECOND_NAME, w.GENDER, w.AGE, w.PLACE_OF_BIRTH, sw.FILMS_NUMBER, sw.GENRES FROM screenwriters AS sw 
    JOIN workers AS w USING(MAIN_WORKER_ID) WHERE sw.WORKER_ID = screenwriter_id;
END
$body$ LANGUAGE plpgsql STABLE;

CREATE OR REPLACE FUNCTION get_regisseur_info(regisseur_id INTEGER) RETURNS 
TABLE(
    WORKER_ID INTEGER, 
    WORKER_NAME VARCHAR,
    WORKER_SECOND_NAME VARCHAR, 
    GENDER VARCHAR, 
    AGE INTEGER, 
    PLACE_OF_BIRTH TEXT,
    FILMS_NUMBER INTEGER,
    GENRES VARCHAR[]) AS
$body$
BEGIN
    RETURN QUERY 
    SELECT r.WORKER_ID, w.NAME, w.SECOND_NAME, w.GENDER, w.AGE, w.PLACE_OF_BIRTH, r.FILMS_NUMBER, r.GENRES FROM regisseurs AS r 
    JOIN workers AS w USING(MAIN_WORKER_ID) WHERE r.WORKER_ID = regisseur_id;
END
$body$ LANGUAGE plpgsql STABLE;

CREATE OR REPLACE FUNCTION get_roles_designer_info(roles_designer_id INTEGER) RETURNS 
TABLE(
    WORKER_ID INTEGER, 
    WORKER_NAME VARCHAR,
    WORKER_SECOND_NAME VARCHAR, 
    GENDER VARCHAR, 
    AGE INTEGER, 
    PLACE_OF_BIRTH TEXT) AS
$body$
BEGIN
    RETURN QUERY SELECT rd.WORKER_ID, w.NAME, w.SECOND_NAME, w.GENDER, w.AGE, w.PLACE_OF_BIRTH FROM roles_designers AS rd 
    JOIN workers AS w USING(MAIN_WORKER_ID) WHERE rd.WORKER_ID = roles_designer_id;
END
$body$ LANGUAGE plpgsql STABLE;

CREATE OR REPLACE FUNCTION get_recording_actor_info(recording_actor_id INTEGER) RETURNS 
TABLE(
    WORKER_ID INTEGER, 
    WORKER_NAME VARCHAR,
    WORKER_SECOND_NAME VARCHAR, 
    GENDER VARCHAR, 
    AGE INTEGER, 
    PLACE_OF_BIRTH TEXT,
    POS RECORDING_ACTORS_POSITIONS) AS
$body$
BEGIN
    RETURN QUERY SELECT ra.WORKER_ID, w.NAME, w.SECOND_NAME, w.GENDER, w.AGE, w.PLACE_OF_BIRTH, ra.POSITION FROM recording_actors AS ra 
    JOIN workers AS w USING(MAIN_WORKER_ID) WHERE ra.WORKER_ID = recording_actor_id;
END
$body$ LANGUAGE plpgsql STABLE;

CREATE OR REPLACE FUNCTION get_editor_info(editor_id INTEGER) RETURNS 
TABLE(
    WORKER_ID INTEGER, 
    WORKER_NAME VARCHAR,
    WORKER_SECOND_NAME VARCHAR, 
    GENDER VARCHAR, 
    AGE INTEGER, 
    PLACE_OF_BIRTH TEXT,
    GENRES VARCHAR[],
    POS EDITOR_POSITIONS) AS
$body$
BEGIN
    RETURN QUERY 
    SELECT e.WORKER_ID, w.NAME, w.SECOND_NAME, w.GENDER, w.AGE, w.PLACE_OF_BIRTH, e.GENRES, e.POSITION FROM editors AS e 
    JOIN workers AS w USING(MAIN_WORKER_ID) WHERE e.WORKER_ID = editor_id;
END
$body$ LANGUAGE plpgsql STABLE;

CREATE OR REPLACE FUNCTION get_artist_info(artist_id INTEGER) RETURNS 
TABLE(
    WORKER_ID INTEGER, 
    WORKER_NAME VARCHAR,
    WORKER_SECOND_NAME VARCHAR, 
    GENDER VARCHAR, 
    AGE INTEGER, 
    PLACE_OF_BIRTH TEXT,
    ARTIST_TYPE ARTIST_TYPES,
    USING_TECHNOLOGY USING_TECHNOLOGIES) AS
$body$
BEGIN
    RETURN QUERY 
    SELECT a.WORKER_ID, w.NAME, w.SECOND_NAME, w.GENDER, w.AGE, w.PLACE_OF_BIRTH, a.ARTIST_TYPE, a.USING_TECHNOLOGY FROM artists AS a 
    JOIN workers AS w USING(MAIN_WORKER_ID) WHERE a.WORKER_ID = artist_id;
END
$body$ LANGUAGE plpgsql STABLE;

/*
*создание функций для процессов
*/
CREATE OR REPLACE FUNCTION get_main_process_joined_artifacts_info() RETURNS 
TABLE(
    MAIN_PROCESS_ID INTEGER,
    DURATION INTEGER, 
    DEADLINE_DATE DATE, 
    DESCRIPTION TEXT, 
    STATUS PROCESS_STATUS, 
    ESTIMATION_TIME INTERVAL, 
    START_DATE DATE, 
    ARTIFACT_ID INTEGER, 
    ARTIFACT_TYPE ARTIFACT_TYPES, 
    SIZE INTEGER, 
    UPLOAD_DATE TIMESTAMP,
    MAIN_WORKER_ID INTEGER) AS
$body$
BEGIN
    RETURN QUERY 
    SELECT 
    mp.MAIN_PROCESS_ID, mp.DURATION, mp.DEADLINE_DATE, mp.DESCRIPTION, mp.STATUS, mp.ESTIMATION_TIME,
    mp.START_DATE, a.ARTIFACT_ID, a.ARTIFACT_TYPE, a.SIZE, a.UPLOAD_DATE, a.MAIN_WORKER_ID
    FROM processes AS mp JOIN process_artifact USING(MAIN_PROCESS_ID) 
    JOIN artifacts AS a USING(ARTIFACT_ID);
END
$body$ LANGUAGE plpgsql STABLE;

CREATE OR REPLACE FUNCTION get_storyboard_process_info(storyboard_process_id INTEGER) RETURNS 
TABLE(
    PROCESS_ID INTEGER,
    FRAME_NUMBER INTEGER,
    DURATION INTEGER, 
    DEADLINE_DATE DATE, 
    DESCRIPTION TEXT, 
    STATUS PROCESS_STATUS, 
    ESTIMATION_TIME INTERVAL, 
    START_DATE DATE, 
    ARTIFACT_ID INTEGER, 
    ARTIFACT_TYPE ARTIFACT_TYPES, 
    SIZE INTEGER, 
    UPLOAD_DATE TIMESTAMP,
    MAIN_WORKER_ID INTEGER) AS
$body$
BEGIN
    RETURN QUERY SELECT 
    sp.PROCESS_ID, sp.FRAME_NUMBER, mpa.DURATION, mpa.DEADLINE_DATE, mpa.DESCRIPTION, mpa.STATUS, mpa.ESTIMATION_TIME, 
    mpa.START_DATE, mpa.ARTIFACT_ID, mpa.ARTIFACT_TYPE, mpa.SIZE, mpa.UPLOAD_DATE, mpa.MAIN_WORKER_ID
    FROM storyboard_process AS sp JOIN get_main_process_joined_artifacts_info() AS mpa USING(MAIN_PROCESS_ID) 
    WHERE sp.PROCESS_ID=storyboard_process_id;
END
$body$ LANGUAGE plpgsql STABLE;

/*
*функции для добавления работников
*/
CREATE OR REPLACE FUNCTION add_storyboard_artist(
    name VARCHAR,
    second_name VARCHAR,
    gender VARCHAR,
    age INTEGER,
    place_of_birth TEXT
) RETURNS BOOLEAN AS
$$
BEGIN
    INSERT INTO workers(NAME, SECOND_NAME, GENDER, AGE, PLACE_OF_BIRTH) VALUES(name, second_name, gender, age, place_of_birth);
    INSERT INTO storyboard_artists(MAIN_WORKER_ID) VALUES(currval('workers_main_worker_id_seq'));
    RETURN TRUE;
END
$$ LANGUAGE plpgsql VOLATILE;

CREATE OR REPLACE FUNCTION add_producer(
    name VARCHAR,
    second_name VARCHAR,
    gender VARCHAR,
    age INTEGER,
    place_of_birth TEXT,
    role VARCHAR
) RETURNS BOOLEAN AS
$$
BEGIN
    INSERT INTO workers(NAME, SECOND_NAME, GENDER, AGE, PLACE_OF_BIRTH) VALUES(name, second_name, gender, age, place_of_birth);
    INSERT INTO producers(MAIN_WORKER_ID, ROLE) VALUES(currval('workers_main_worker_id_seq'), role::PRODUCER_ROLES);
    RETURN TRUE;
END
$$ LANGUAGE plpgsql VOLATILE;

CREATE OR REPLACE FUNCTION add_audio_specialist(
    name VARCHAR,
    second_name VARCHAR,
    gender VARCHAR,
    age INTEGER,
    place_of_birth TEXT
) RETURNS BOOLEAN AS
$$
BEGIN
    INSERT INTO workers(NAME, SECOND_NAME, GENDER, AGE, PLACE_OF_BIRTH) VALUES(name, second_name, gender, age, place_of_birth);
    INSERT INTO audio_specialist(MAIN_WORKER_ID) VALUES(currval('workers_main_worker_id_seq'));
    RETURN TRUE;
END
$$ LANGUAGE plpgsql VOLATILE;

CREATE OR REPLACE FUNCTION add_digitizer(
    name VARCHAR,
    second_name VARCHAR,
    gender VARCHAR,
    age INTEGER,
    place_of_birth TEXT
) RETURNS BOOLEAN AS
$$
BEGIN
    INSERT INTO workers(NAME, SECOND_NAME, GENDER, AGE, PLACE_OF_BIRTH) VALUES(name, second_name, gender, age, place_of_birth);
    INSERT INTO digitizers(MAIN_WORKER_ID) VALUES(currval('workers_main_worker_id_seq'));
    RETURN TRUE;
END
$$ LANGUAGE plpgsql VOLATILE;

CREATE OR REPLACE FUNCTION add_smoothing_specialist(
    name VARCHAR,
    second_name VARCHAR,
    gender VARCHAR,
    age INTEGER,
    place_of_birth TEXT
) RETURNS BOOLEAN AS
$$
BEGIN
    INSERT INTO workers(NAME, SECOND_NAME, GENDER, AGE, PLACE_OF_BIRTH) VALUES(name, second_name, gender, age, place_of_birth);
    INSERT INTO smoothing_specialist(MAIN_WORKER_ID) VALUES(currval('workers_main_worker_id_seq'));
    RETURN TRUE;
END
$$ LANGUAGE plpgsql VOLATILE;

CREATE OR REPLACE FUNCTION add_art_director(
    name VARCHAR,
    second_name VARCHAR,
    gender VARCHAR,
    age INTEGER,
    place_of_birth TEXT
) RETURNS BOOLEAN AS
$$
BEGIN
    INSERT INTO workers(NAME, SECOND_NAME, GENDER, AGE, PLACE_OF_BIRTH) VALUES(name, second_name, gender, age, place_of_birth);
    INSERT INTO art_director(MAIN_WORKER_ID) VALUES(currval('workers_main_worker_id_seq'));
    RETURN TRUE;
END
$$ LANGUAGE plpgsql VOLATILE;

CREATE OR REPLACE FUNCTION add_screenwriter(
    name VARCHAR,
    second_name VARCHAR,
    gender VARCHAR,
    age INTEGER,
    place_of_birth TEXT,
    films_number INTEGER,
    genres VARCHAR[]
) RETURNS BOOLEAN AS
$$
BEGIN
    INSERT INTO workers(NAME, SECOND_NAME, GENDER, AGE, PLACE_OF_BIRTH) VALUES(name, second_name, gender, age, place_of_birth);
    INSERT INTO screenwriters(MAIN_WORKER_ID, FILMS_NUMBER, GENRES) VALUES(currval('workers_main_worker_id_seq'), films_number, genres);
    RETURN TRUE;
END
$$ LANGUAGE plpgsql VOLATILE;

CREATE OR REPLACE FUNCTION add_regisseur(
    name VARCHAR,
    second_name VARCHAR,
    gender VARCHAR,
    age INTEGER,
    place_of_birth TEXT,
    films_number INTEGER,
    genres VARCHAR[]
) RETURNS BOOLEAN AS
$$
BEGIN
    INSERT INTO workers(NAME, SECOND_NAME, GENDER, AGE, PLACE_OF_BIRTH) VALUES(name, second_name, gender, age, place_of_birth);
    INSERT INTO regisseurs(MAIN_WORKER_ID, FILMS_NUMBER, GENRES) VALUES(currval('workers_main_worker_id_seq'), films_number, genres);
    RETURN TRUE;
END
$$ LANGUAGE plpgsql VOLATILE;

CREATE OR REPLACE FUNCTION add_roles_designer(
    name VARCHAR,
    second_name VARCHAR,
    gender VARCHAR,
    age INTEGER,
    place_of_birth TEXT
) RETURNS BOOLEAN AS
$$
BEGIN
    INSERT INTO workers(NAME, SECOND_NAME, GENDER, AGE, PLACE_OF_BIRTH) VALUES(name, second_name, gender, age, place_of_birth);
    INSERT INTO roles_designers(MAIN_WORKER_ID) VALUES(currval('workers_main_worker_id_seq'));
    RETURN TRUE;
END
$$ LANGUAGE plpgsql VOLATILE;

CREATE OR REPLACE FUNCTION add_recording_actor(
    name VARCHAR,
    second_name VARCHAR,
    gender VARCHAR,
    age INTEGER,
    place_of_birth TEXT,
    position VARCHAR
) RETURNS BOOLEAN AS
$$
BEGIN
    INSERT INTO workers(NAME, SECOND_NAME, GENDER, AGE, PLACE_OF_BIRTH) VALUES(name, second_name, gender, age, place_of_birth);
    INSERT INTO recording_actors(MAIN_WORKER_ID, POSITION) VALUES(currval('workers_main_worker_id_seq'), position::RECORDING_ACTORS_POSITIONS);
    RETURN TRUE;
END
$$ LANGUAGE plpgsql VOLATILE;

CREATE OR REPLACE FUNCTION add_editor(
    name VARCHAR,
    second_name VARCHAR,
    gender VARCHAR,
    age INTEGER,
    place_of_birth TEXT,
    genres VARCHAR[],
    position VARCHAR
) RETURNS BOOLEAN AS
$$
BEGIN
    INSERT INTO workers(NAME, SECOND_NAME, GENDER, AGE, PLACE_OF_BIRTH) VALUES(name, second_name, gender, age, place_of_birth);
    INSERT INTO editors(MAIN_WORKER_ID, GENRES, POSITION) VALUES(currval('workers_main_worker_id_seq'), genres, position::EDITOR_POSITIONS);
    RETURN TRUE;
END
$$ LANGUAGE plpgsql VOLATILE;

CREATE OR REPLACE FUNCTION add_artist(
    name VARCHAR,
    second_name VARCHAR,
    gender VARCHAR,
    age INTEGER,
    place_of_birth TEXT,
    artist_type VARCHAR,
    using_technology VARCHAR
) RETURNS BOOLEAN AS
$$
BEGIN
    INSERT INTO workers(NAME, SECOND_NAME, GENDER, AGE, PLACE_OF_BIRTH) VALUES(name, second_name, gender, age, place_of_birth);
    INSERT INTO artists(MAIN_WORKER_ID, ARTIST_TYPE, USING_TECHNOLOGY) VALUES(currval('workers_main_worker_id_seq'), artist_type::ARTIST_TYPES, using_technology::USING_TECHNOLOGIES);
    RETURN TRUE;
END
$$ LANGUAGE plpgsql VOLATILE;

/*
*функции для добавления процессов
*/
CREATE OR REPLACE FUNCTION create_storyboard_process(
    duration INTEGER,
    deadline_date DATE,
    description TEXT,
    status VARCHAR,
    estimation_time INTERVAL,
    start_date DATE,
    frame_number INTEGER
) RETURNS BOOLEAN AS
$$
BEGIN
    INSERT INTO processes(DURATION, DEADLINE_DATE, DESCRIPTION, STATUS, ESTIMATION_TIME, START_DATE) 
    VALUES(duration, deadline_date, description, status::PROCESS_STATUS, estimation_time, start_date);
    INSERT INTO storyboard_process(MAIN_PROCESS_ID, FRAME_NUMBER) VALUES(currval('processes_main_process_id_seq'), frame_number);
    RETURN TRUE;
END
$$ LANGUAGE plpgsql VOLATILE;

CREATE OR REPLACE FUNCTION create_advertising_process(
    duration INTEGER,
    deadline_date DATE,
    description TEXT,
    status VARCHAR,
    estimation_time INTERVAL,
    start_date DATE,
    insertion_location VARCHAR
) RETURNS BOOLEAN AS
$$
BEGIN
    INSERT INTO processes(DURATION, DEADLINE_DATE, DESCRIPTION, STATUS, ESTIMATION_TIME, START_DATE) 
    VALUES(duration, deadline_date, description, status::PROCESS_STATUS, estimation_time, start_date);
    INSERT INTO advertising_process(MAIN_PROCESS_ID, INSERTION_LOCATION) VALUES(currval('processes_main_process_id_seq'), insertion_location::INSERTION_LOCATIONS);
    RETURN TRUE;
END
$$ LANGUAGE plpgsql VOLATILE;

CREATE OR REPLACE FUNCTION create_adding_sound_effect_process(
    duration INTEGER,
    deadline_date DATE,
    description TEXT,
    status VARCHAR,
    estimation_time INTERVAL,
    start_date DATE,
    sound_type VARCHAR
) RETURNS BOOLEAN AS
$$
BEGIN
    INSERT INTO processes(DURATION, DEADLINE_DATE, DESCRIPTION, STATUS, ESTIMATION_TIME, START_DATE) 
    VALUES(duration, deadline_date, description, status::PROCESS_STATUS, estimation_time, start_date);
    INSERT INTO adding_sound_process(MAIN_PROCESS_ID, SOUND_TYPE) VALUES(currval('processes_main_process_id_seq'), sound_type::SOUND_TYPES);
    RETURN TRUE;
END
$$ LANGUAGE plpgsql VOLATILE;

CREATE OR REPLACE FUNCTION create_digitization_process(
    duration INTEGER,
    deadline_date DATE,
    description TEXT,
    status VARCHAR,
    estimation_time INTERVAL,
    start_date DATE,
    sketches_number INTEGER,
    digitization_type VARCHAR
) RETURNS BOOLEAN AS
$$
BEGIN
    INSERT INTO processes(DURATION, DEADLINE_DATE, DESCRIPTION, STATUS, ESTIMATION_TIME, START_DATE) 
    VALUES(duration, deadline_date, description, status::PROCESS_STATUS, estimation_time, start_date);
    INSERT INTO digitization_process(MAIN_PROCESS_ID, SKETCHES_NUMBER, DIGITIZATION_TYPE) 
    VALUES(currval('processes_main_process_id_seq'), sketches_number, digitization_type::DIGITIZATION_TYPES);
    RETURN TRUE;
END
$$ LANGUAGE plpgsql VOLATILE;

CREATE OR REPLACE FUNCTION create_smoothing_process(
    duration INTEGER,
    deadline_date DATE,
    description TEXT,
    status VARCHAR,
    estimation_time INTERVAL,
    start_date DATE
) RETURNS BOOLEAN AS
$$
BEGIN
    INSERT INTO processes(DURATION, DEADLINE_DATE, DESCRIPTION, STATUS, ESTIMATION_TIME, START_DATE) 
    VALUES(duration, deadline_date, description, status::PROCESS_STATUS, estimation_time, start_date);
    INSERT INTO smoothing_process(MAIN_PROCESS_ID) VALUES(currval('processes_main_process_id_seq'));
    RETURN TRUE;
END
$$ LANGUAGE plpgsql VOLATILE;

CREATE OR REPLACE FUNCTION create_revision_process(
    duration INTEGER,
    deadline_date DATE,
    description TEXT,
    status VARCHAR,
    estimation_time INTERVAL,
    start_date DATE,
    revision_type VARCHAR
) RETURNS BOOLEAN AS
$$
BEGIN
    INSERT INTO processes(DURATION, DEADLINE_DATE, DESCRIPTION, STATUS, ESTIMATION_TIME, START_DATE) 
    VALUES(duration, deadline_date, description, status::PROCESS_STATUS, estimation_time, start_date);
    INSERT INTO revisions_process(MAIN_PROCESS_ID, REVISION_TYPE) VALUES(currval('processes_main_process_id_seq'), revision_type::REVISION_TYPES);
    RETURN TRUE;
END
$$ LANGUAGE plpgsql VOLATILE;

CREATE OR REPLACE FUNCTION create_coloring_process(
    duration INTEGER,
    deadline_date DATE,
    description TEXT,
    status VARCHAR,
    estimation_time INTERVAL,
    start_date DATE,
    coloring_type VARCHAR
) RETURNS BOOLEAN AS
$$
BEGIN
    INSERT INTO processes(DURATION, DEADLINE_DATE, DESCRIPTION, STATUS, ESTIMATION_TIME, START_DATE) 
    VALUES(duration, deadline_date, description, status::PROCESS_STATUS, estimation_time, start_date);
    INSERT INTO coloring_process(MAIN_PROCESS_ID, COLORING_TYPE) VALUES(currval('processes_main_process_id_seq'), coloring_type::COLORING_TYPES);
    RETURN TRUE;
END
$$ LANGUAGE plpgsql VOLATILE;

CREATE OR REPLACE FUNCTION create_animation_process(
    duration INTEGER,
    deadline_date DATE,
    description TEXT,
    status VARCHAR,
    estimation_time INTERVAL,
    start_date DATE,
    frame_rate INTEGER,
    animation_technology VARCHAR
) RETURNS BOOLEAN AS
$$
BEGIN
    INSERT INTO processes(DURATION, DEADLINE_DATE, DESCRIPTION, STATUS, ESTIMATION_TIME, START_DATE) 
    VALUES(duration, deadline_date, description, status::PROCESS_STATUS, estimation_time, start_date);
    INSERT INTO animation_process(MAIN_PROCESS_ID, FRAME_RATE, ANIMATION_TECHNOLOGY) 
    VALUES(currval('processes_main_process_id_seq'), frame_rate, animation_technology);
    RETURN TRUE;
END
$$ LANGUAGE plpgsql VOLATILE;

CREATE OR REPLACE FUNCTION create_adding_effect_process(
    duration INTEGER,
    deadline_date DATE,
    description TEXT,
    status VARCHAR,
    estimation_time INTERVAL,
    start_date DATE,
    effect_level VARCHAR
) RETURNS BOOLEAN AS
$$
BEGIN
    INSERT INTO processes(DURATION, DEADLINE_DATE, DESCRIPTION, STATUS, ESTIMATION_TIME, START_DATE) 
    VALUES(duration, deadline_date, description, status::PROCESS_STATUS, estimation_time, start_date);
    INSERT INTO adding_effect_process(MAIN_PROCESS_ID, EFFECT_LEVEL) VALUES(currval('processes_main_process_id_seq'), effect_level::EFFECT_LEVELS);
    RETURN TRUE;
END
$$ LANGUAGE plpgsql VOLATILE;

CREATE OR REPLACE FUNCTION create_location_drawing_process(
    duration INTEGER,
    deadline_date DATE,
    description TEXT,
    status VARCHAR,
    estimation_time INTERVAL,
    start_date DATE
) RETURNS BOOLEAN AS
$$
BEGIN
    INSERT INTO processes(DURATION, DEADLINE_DATE, DESCRIPTION, STATUS, ESTIMATION_TIME, START_DATE) 
    VALUES(duration, deadline_date, description, status::PROCESS_STATUS, estimation_time, start_date);
    INSERT INTO location_drawing_process(MAIN_PROCESS_ID) VALUES(currval('processes_main_process_id_seq'));
    RETURN TRUE;
END
$$ LANGUAGE plpgsql VOLATILE;

CREATE OR REPLACE FUNCTION create_battle_drawing_process(
    duration INTEGER,
    deadline_date DATE,
    description TEXT,
    status VARCHAR,
    estimation_time INTERVAL,
    start_date DATE
) RETURNS BOOLEAN AS
$$
BEGIN
    INSERT INTO processes(DURATION, DEADLINE_DATE, DESCRIPTION, STATUS, ESTIMATION_TIME, START_DATE) 
    VALUES(duration, deadline_date, description, status::PROCESS_STATUS, estimation_time, start_date);
    INSERT INTO battle_drawing_process(MAIN_PROCESS_ID) VALUES(currval('processes_main_process_id_seq'));
    RETURN TRUE;
END
$$ LANGUAGE plpgsql VOLATILE;

CREATE OR REPLACE FUNCTION create_character_drawing_process(
    duration INTEGER,
    deadline_date DATE,
    description TEXT,
    status VARCHAR,
    estimation_time INTERVAL,
    start_date DATE
) RETURNS BOOLEAN AS
$$
BEGIN
    INSERT INTO processes(DURATION, DEADLINE_DATE, DESCRIPTION, STATUS, ESTIMATION_TIME, START_DATE) 
    VALUES(duration, deadline_date, description, status::PROCESS_STATUS, estimation_time, start_date);
    INSERT INTO character_drawing_process(MAIN_PROCESS_ID) VALUES(currval('processes_main_process_id_seq'));
    RETURN TRUE;
END
$$ LANGUAGE plpgsql VOLATILE;

CREATE OR REPLACE FUNCTION create_character_select_process(
    duration INTEGER,
    deadline_date DATE,
    description TEXT,
    status VARCHAR,
    estimation_time INTERVAL,
    start_date DATE
) RETURNS BOOLEAN AS
$$
BEGIN
    INSERT INTO processes(DURATION, DEADLINE_DATE, DESCRIPTION, STATUS, ESTIMATION_TIME, START_DATE) 
    VALUES(duration, deadline_date, description, status::PROCESS_STATUS, estimation_time, start_date);
    INSERT INTO character_select_process(MAIN_PROCESS_ID) VALUES(currval('processes_main_process_id_seq'));
    RETURN TRUE;
END
$$ LANGUAGE plpgsql VOLATILE;

CREATE OR REPLACE FUNCTION create_voice_acting_process(
    duration INTEGER,
    deadline_date DATE,
    description TEXT,
    status VARCHAR,
    estimation_time INTERVAL,
    start_date DATE,
    voice_acting_type VARCHAR
) RETURNS BOOLEAN AS
$$
BEGIN
    INSERT INTO processes(DURATION, DEADLINE_DATE, DESCRIPTION, STATUS, ESTIMATION_TIME, START_DATE) 
    VALUES(duration, deadline_date, description, status::PROCESS_STATUS, estimation_time, start_date);
    INSERT INTO voice_acting_process(MAIN_PROCESS_ID, VOICE_ACTING_TYPE) VALUES(currval('processes_main_process_id_seq'), voice_acting_type::VOICE_ACTING_TYPES);
    RETURN TRUE;
END
$$ LANGUAGE plpgsql VOLATILE;

CREATE OR REPLACE FUNCTION create_ability_description_process(
    duration INTEGER,
    deadline_date DATE,
    description TEXT,
    status VARCHAR,
    estimation_time INTERVAL,
    start_date DATE
) RETURNS BOOLEAN AS
$$
BEGIN
    INSERT INTO processes(DURATION, DEADLINE_DATE, DESCRIPTION, STATUS, ESTIMATION_TIME, START_DATE) 
    VALUES(duration, deadline_date, description, status::PROCESS_STATUS, estimation_time, start_date);
    INSERT INTO ability_description_process(MAIN_PROCESS_ID) VALUES(currval('processes_main_process_id_seq'));
    RETURN TRUE;
END
$$ LANGUAGE plpgsql VOLATILE;

CREATE OR REPLACE FUNCTION create_character_description_process(
    duration INTEGER,
    deadline_date DATE,
    description TEXT,
    status VARCHAR,
    estimation_time INTERVAL,
    start_date DATE
) RETURNS BOOLEAN AS
$$
BEGIN
    INSERT INTO processes(DURATION, DEADLINE_DATE, DESCRIPTION, STATUS, ESTIMATION_TIME, START_DATE) 
    VALUES(duration, deadline_date, description, status::PROCESS_STATUS, estimation_time, start_date);
    INSERT INTO character_description_process(MAIN_PROCESS_ID) VALUES(currval('processes_main_process_id_seq'));
    RETURN TRUE;
END
$$ LANGUAGE plpgsql VOLATILE;

CREATE OR REPLACE FUNCTION create_location_description_process(
    duration INTEGER,
    deadline_date DATE,
    description TEXT,
    status VARCHAR,
    estimation_time INTERVAL,
    start_date DATE
) RETURNS BOOLEAN AS
$$
BEGIN
    INSERT INTO processes(DURATION, DEADLINE_DATE, DESCRIPTION, STATUS, ESTIMATION_TIME, START_DATE) 
    VALUES(duration, deadline_date, description, status::PROCESS_STATUS, estimation_time, start_date);
    INSERT INTO location_description_process(MAIN_PROCESS_ID) VALUES(currval('processes_main_process_id_seq'));
    RETURN TRUE;
END
$$ LANGUAGE plpgsql VOLATILE;

CREATE OR REPLACE FUNCTION create_battle_description_process(
    duration INTEGER,
    deadline_date DATE,
    description TEXT,
    status VARCHAR,
    estimation_time INTERVAL,
    start_date DATE
) RETURNS BOOLEAN AS
$$
BEGIN
    INSERT INTO processes(DURATION, DEADLINE_DATE, DESCRIPTION, STATUS, ESTIMATION_TIME, START_DATE) 
    VALUES(duration, deadline_date, description, status::PROCESS_STATUS, estimation_time, start_date);
    INSERT INTO battle_description_process(MAIN_PROCESS_ID) VALUES(currval('processes_main_process_id_seq'));
    RETURN TRUE;
END
$$ LANGUAGE plpgsql VOLATILE;

CREATE OR REPLACE FUNCTION create_plot_process(
    duration INTEGER,
    deadline_date DATE,
    description TEXT,
    status VARCHAR,
    estimation_time INTERVAL,
    start_date DATE
) RETURNS BOOLEAN AS
$$
BEGIN
    INSERT INTO processes(DURATION, DEADLINE_DATE, DESCRIPTION, STATUS, ESTIMATION_TIME, START_DATE) 
    VALUES(duration, deadline_date, description, status::PROCESS_STATUS, estimation_time, start_date);
    INSERT INTO plot_process(MAIN_PROCESS_ID) VALUES(currval('processes_main_process_id_seq'));
    RETURN TRUE;
END
$$ LANGUAGE plpgsql VOLATILE;

/*
*функции для добавления артефактов
*/
CREATE OR REPLACE FUNCTION create_artifact(
    upload_user INTEGER,
    artifact_type VARCHAR,
    size INTEGER,
    upload_date DATE
) RETURNS BOOLEAN AS
$$
BEGIN
    INSERT INTO artifacts(MAIN_WORKER_ID, ARTIFACT_TYPE, SIZE, UPLOAD_DATE) VALUES(upload_user, artifact_type::ARTIFACT_TYPES, size, upload_date);
    RETURN TRUE;
END
$$ LANGUAGE plpgsql VOLATILE;

/*
*функции для добавления основных стержневых сущностей
*/
CREATE OR REPLACE FUNCTION create_plot(
    process_id INTEGER,
    pages_number INTEGER,
    plot_type VARCHAR,
    description TEXT,
    narrative_period INTERVAL,
    plot_name VARCHAR
) RETURNS BOOLEAN AS
$$
BEGIN
    INSERT INTO plot(PROCESS_ID, PAGES_NUMBER, PLOT_TYPE, DESCRIPTION, NARRATIVE_PERIOD, PLOT_NAME) 
    VALUES(process_id, pages_number, plot_type::PLOT_TYPES, description, narrative_period, plot_name);
    RETURN TRUE;
END
$$ LANGUAGE plpgsql VOLATILE;

CREATE OR REPLACE FUNCTION create_events(
    description TEXT,
    importance_level INTEGER,
    event_name VARCHAR
) RETURNS BOOLEAN AS
$$
BEGIN
    INSERT INTO events(EVENT_NAME, DESCRIPTION, IMPORTANCE_LEVEL) 
    VALUES(event_name, description, importance_level);
    RETURN TRUE;
END
$$ LANGUAGE plpgsql VOLATILE;

CREATE OR REPLACE FUNCTION create_locations(
    description_id INTEGER,
    drawing_id INTEGER,
    area INTEGER,
    location_type VARCHAR,
    for_battle BOOLEAN,
    location_name VARCHAR
) RETURNS BOOLEAN AS
$$
BEGIN
    INSERT INTO locations(DESCRIPTION_ID, DRAWING_ID, AREA, LOCATION_TYPE, FOR_BATTLE, LOCATION_NAME) 
    VALUES(description_id, drawing_id, area, location_type::LOCATION_TYPES, for_battle, location_name);
    RETURN TRUE;
END
$$ LANGUAGE plpgsql VOLATILE;

CREATE OR REPLACE FUNCTION create_battle(
    description_id INTEGER,
    drawing_id INTEGER,
    duration NUMERIC,
    battle_name VARCHAR
) RETURNS BOOLEAN AS
$$
BEGIN
    INSERT INTO battle(DESCRIPTION_ID, DRAWING_ID, DURATION, BATTLE_NAME) 
    VALUES(description_id, drawing_id, duration, battle_name);
    RETURN TRUE;
END
$$ LANGUAGE plpgsql VOLATILE;

CREATE OR REPLACE FUNCTION create_abilities(
    description_id INTEGER,
    ability_name VARCHAR,
    description TEXT,
    ability_type VARCHAR,
    complexity_level INTEGER
) RETURNS BOOLEAN AS
$$
BEGIN
    INSERT INTO abilities(DESCRIPTION_ID, ABILITY_NAME, DESCRIPTION, ABILITY_TYPE, COMPLEXITY_LEVEL) 
    VALUES(description_id, ability_name, description, ability_type::ABILITY_TYPES, complexity_level);
    RETURN TRUE;
END
$$ LANGUAGE plpgsql VOLATILE;

CREATE OR REPLACE FUNCTION create_character(
    voice_acting_id INTEGER,
    selection_id INTEGER,
    drawing_id INTEGER,
    description_id INTEGER,
    character_name VARCHAR,
    gender VARCHAR,
    protagonist BOOLEAN,
    positive BOOLEAN,
    age INTEGER,
    birth_date DATE
) RETURNS BOOLEAN AS
$$
BEGIN
    INSERT INTO abilities(VOICE_ACTING_ID, SELECTION_ID, DRAWING_ID, DESCRIPTION_ID, CHARACTER_NAME, GENDER, PROTAGONIST, POSITIVE, AGE, BIRTH_DATE) 
    VALUES(voice_acting_id, selection_id, drawing_id, description_id, character_name, gender, protagonist, positive, age, birth_date);
    RETURN TRUE;
END
$$ LANGUAGE plpgsql VOLATILE;

/*
*функции для удаления работников
*/
CREATE OR REPLACE FUNCTION delete_storyboarder(main_worker_id INTEGER) RETURNS BOOLEAN AS
$$
BEGIN
    DELETE FROM storyboard_artists WHERE storyboard_artists.MAIN_WORKER_ID = main_worker_id;
    RETURN TRUE;
END
$$
LANGUAGE plpgsql VOLATILE;

CREATE OR REPLACE FUNCTION delete_producer(main_worker_id INTEGER) RETURNS BOOLEAN AS
$$
BEGIN
    DELETE FROM producer WHERE producer.MAIN_WORKER_ID = main_worker_id;
    RETURN TRUE;
END
$$
LANGUAGE plpgsql VOLATILE;

CREATE OR REPLACE FUNCTION delete_audio_specialist(main_worker_id INTEGER) RETURNS BOOLEAN AS
$$
BEGIN
    DELETE FROM audio_specialist WHERE audio_specialist.MAIN_WORKER_ID = main_worker_id;
    RETURN TRUE;
END
$$
LANGUAGE plpgsql VOLATILE;

CREATE OR REPLACE FUNCTION delete_digitizer(main_worker_id INTEGER) RETURNS BOOLEAN AS
$$
BEGIN
    DELETE FROM digitizers WHERE digitizers.MAIN_WORKER_ID = main_worker_id;
    RETURN TRUE;
END
$$
LANGUAGE plpgsql VOLATILE;

CREATE OR REPLACE FUNCTION delete_smoothing_specialist(main_worker_id INTEGER) RETURNS BOOLEAN AS
$$
BEGIN
    DELETE FROM smoothing_specialist WHERE smoothing_specialist.MAIN_WORKER_ID = main_worker_id;
    RETURN TRUE;
END
$$
LANGUAGE plpgsql VOLATILE;

CREATE OR REPLACE FUNCTION delete_art_director(main_worker_id INTEGER) RETURNS BOOLEAN AS
$$
BEGIN
    DELETE FROM art_director WHERE art_director.MAIN_WORKER_ID = main_worker_id;
    RETURN TRUE;
END
$$
LANGUAGE plpgsql VOLATILE;

CREATE OR REPLACE FUNCTION delete_screenwriter(main_worker_id INTEGER) RETURNS BOOLEAN AS
$$
BEGIN
    DELETE FROM screenwriters WHERE screenwriters.MAIN_WORKER_ID = main_worker_id;
    RETURN TRUE;
END
$$
LANGUAGE plpgsql VOLATILE;

CREATE OR REPLACE FUNCTION delete_regisseur(main_worker_id INTEGER) RETURNS BOOLEAN AS
$$
BEGIN
    DELETE FROM regisseurs WHERE regisseurs.MAIN_WORKER_ID = main_worker_id;
    RETURN TRUE;
END
$$
LANGUAGE plpgsql VOLATILE;

CREATE OR REPLACE FUNCTION delete_roles_designer(main_worker_id INTEGER) RETURNS BOOLEAN AS
$$
BEGIN
    DELETE FROM roles_designers WHERE roles_designers.MAIN_WORKER_ID = main_worker_id;
    RETURN TRUE;
END
$$
LANGUAGE plpgsql VOLATILE;

CREATE OR REPLACE FUNCTION delete_recording_actor(main_worker_id INTEGER) RETURNS BOOLEAN AS
$$
BEGIN
    DELETE FROM recording_actors WHERE recording_actors.MAIN_WORKER_ID = main_worker_id;
    RETURN TRUE;
END
$$
LANGUAGE plpgsql VOLATILE;

CREATE OR REPLACE FUNCTION delete_editor(main_worker_id INTEGER) RETURNS BOOLEAN AS
$$
BEGIN
    DELETE FROM editors WHERE editors.MAIN_WORKER_ID = main_worker_id;
    RETURN TRUE;
END
$$
LANGUAGE plpgsql VOLATILE;

CREATE OR REPLACE FUNCTION delete_artist(main_worker_id INTEGER) RETURNS BOOLEAN AS
$$
BEGIN
    DELETE FROM artists WHERE artists.MAIN_WORKER_ID = main_worker_id;
    RETURN TRUE;
END
$$
LANGUAGE plpgsql VOLATILE;

CREATE OR REPLACE FUNCTION delete_account(main_worker_id INTEGER) RETURNS BOOLEAN AS
$$
BEGIN
    DELETE FROM workers WHERE workers.MAIN_WORKER_ID = main_worker_id;
    RETURN TRUE;
END
$$
LANGUAGE plpgsql VOLATILE;

/*
*создание функций для удаления процессов
*/
CREATE OR REPLACE FUNCTION delete_process(main_process_id INTEGER) RETURNS BOOLEAN AS
$$
BEGIN
    DELETE FROM processes WHERE processes.MAIN_PROCESS_ID=main_process_id;
    RETURN TRUE;
END
$$
LANGUAGE plpgsql VOLATILE;

CREATE OR REPLACE FUNCTION delete_storyboard_process(main_process_id INTEGER) RETURNS BOOLEAN AS
$$
BEGIN
    DELETE FROM storyboard_process WHERE storyboard_process.MAIN_PROCESS_ID=main_process_id;
    RETURN TRUE;
END
$$
LANGUAGE plpgsql VOLATILE;

CREATE OR REPLACE FUNCTION delete_advertising_process(main_process_id INTEGER) RETURNS BOOLEAN AS
$$
BEGIN
    DELETE FROM advertising_process WHERE advertising_process.MAIN_PROCESS_ID=main_process_id;
    RETURN TRUE;
END
$$
LANGUAGE plpgsql VOLATILE;

CREATE OR REPLACE FUNCTION delete_adding_sound_process(main_process_id INTEGER) RETURNS BOOLEAN AS
$$
BEGIN
    DELETE FROM adding_sound_process WHERE adding_sound_process.MAIN_PROCESS_ID=main_process_id;
    RETURN TRUE;
END
$$
LANGUAGE plpgsql VOLATILE;

CREATE OR REPLACE FUNCTION delete_digitization_process(main_process_id INTEGER) RETURNS BOOLEAN AS
$$
BEGIN
    DELETE FROM digitization_process WHERE digitization_process.MAIN_PROCESS_ID=main_process_id;
    RETURN TRUE;
END
$$
LANGUAGE plpgsql VOLATILE;

CREATE OR REPLACE FUNCTION delete_smoothing_process(main_process_id INTEGER) RETURNS BOOLEAN AS
$$
BEGIN
    DELETE FROM smoothing_process WHERE smoothing_process.MAIN_PROCESS_ID=main_process_id;
    RETURN TRUE;
END
$$
LANGUAGE plpgsql VOLATILE;

CREATE OR REPLACE FUNCTION delete_revisions_process(main_process_id INTEGER) RETURNS BOOLEAN AS
$$
BEGIN
    DELETE FROM revisions_process WHERE revisions_process.MAIN_PROCESS_ID=main_process_id;
    RETURN TRUE;
END
$$
LANGUAGE plpgsql VOLATILE;

CREATE OR REPLACE FUNCTION delete_coloring_process(main_process_id INTEGER) RETURNS BOOLEAN AS
$$
BEGIN
    DELETE FROM coloring_process WHERE coloring_process.MAIN_PROCESS_ID=main_process_id;
    RETURN TRUE;
END
$$
LANGUAGE plpgsql VOLATILE;

CREATE OR REPLACE FUNCTION delete_animation_process(main_process_id INTEGER) RETURNS BOOLEAN AS
$$
BEGIN
    DELETE FROM animation_process WHERE animation_process.MAIN_PROCESS_ID=main_process_id;
    RETURN TRUE;
END
$$
LANGUAGE plpgsql VOLATILE;

CREATE OR REPLACE FUNCTION delete_adding_effect_process(main_process_id INTEGER) RETURNS BOOLEAN AS
$$
BEGIN
    DELETE FROM adding_effect_process WHERE adding_effect_process.MAIN_PROCESS_ID=main_process_id;
    RETURN TRUE;
END
$$
LANGUAGE plpgsql VOLATILE;

CREATE OR REPLACE FUNCTION delete_location_drawing_process(main_process_id INTEGER) RETURNS BOOLEAN AS
$$
BEGIN
    DELETE FROM location_drawing_process WHERE location_drawing_process.MAIN_PROCESS_ID=main_process_id;
    RETURN TRUE;
END
$$
LANGUAGE plpgsql VOLATILE;

CREATE OR REPLACE FUNCTION delete_battle_drawing_process(main_process_id INTEGER) RETURNS BOOLEAN AS
$$
BEGIN
    DELETE FROM battle_drawing_process WHERE battle_drawing_process.MAIN_PROCESS_ID=main_process_id;
    RETURN TRUE;
END
$$
LANGUAGE plpgsql VOLATILE;

CREATE OR REPLACE FUNCTION delete_character_drawing_process(main_process_id INTEGER) RETURNS BOOLEAN AS
$$
BEGIN
    DELETE FROM character_drawing_process WHERE character_drawing_process.MAIN_PROCESS_ID=main_process_id;
    RETURN TRUE;
END
$$
LANGUAGE plpgsql VOLATILE;

CREATE OR REPLACE FUNCTION delete_character_select_process(main_process_id INTEGER) RETURNS BOOLEAN AS
$$
BEGIN
    DELETE FROM character_select_process WHERE character_select_process.MAIN_PROCESS_ID=main_process_id;
    RETURN TRUE;
END
$$
LANGUAGE plpgsql VOLATILE;

CREATE OR REPLACE FUNCTION delete_voice_acting_process(main_process_id INTEGER) RETURNS BOOLEAN AS
$$
BEGIN
    DELETE FROM voice_acting_process WHERE voice_acting_process.MAIN_PROCESS_ID=main_process_id;
    RETURN TRUE;
END
$$
LANGUAGE plpgsql VOLATILE;

CREATE OR REPLACE FUNCTION delete_ability_description_process(main_process_id INTEGER) RETURNS BOOLEAN AS
$$
BEGIN
    DELETE FROM ability_description_process WHERE ability_description_process.MAIN_PROCESS_ID=main_process_id;
    RETURN TRUE;
END
$$
LANGUAGE plpgsql VOLATILE;

CREATE OR REPLACE FUNCTION delete_character_description_process(main_process_id INTEGER) RETURNS BOOLEAN AS
$$
BEGIN
    DELETE FROM character_description_process WHERE character_description_process.MAIN_PROCESS_ID=main_process_id;
    RETURN TRUE;
END
$$
LANGUAGE plpgsql VOLATILE;

CREATE OR REPLACE FUNCTION delete_location_description_process(main_process_id INTEGER) RETURNS BOOLEAN AS
$$
BEGIN
    DELETE FROM location_description_process WHERE location_description_process.MAIN_PROCESS_ID=main_process_id;
    RETURN TRUE;
END
$$
LANGUAGE plpgsql VOLATILE;

CREATE OR REPLACE FUNCTION delete_battle_description_process(main_process_id INTEGER) RETURNS BOOLEAN AS
$$
BEGIN
    DELETE FROM battle_description_process WHERE battle_description_process.MAIN_PROCESS_ID=main_process_id;
    RETURN TRUE;
END
$$
LANGUAGE plpgsql VOLATILE;

CREATE OR REPLACE FUNCTION delete_plot_process(main_process_id INTEGER) RETURNS BOOLEAN AS
$$
BEGIN
    DELETE FROM plot_process WHERE plot_process.MAIN_PROCESS_ID=main_process_id;
    RETURN TRUE;
END
$$
LANGUAGE plpgsql VOLATILE;

/*
*функции для удаления основных сущностей
*/
CREATE OR REPLACE FUNCTION delete_plot(plot_id INTEGER) RETURNS BOOLEAN AS
$$
BEGIN
    DELETE FROM plot WHERE plot.PLOT_ID=plot_id;
    RETURN TRUE;
END
$$
LANGUAGE plpgsql VOLATILE;

CREATE OR REPLACE FUNCTION delete_events(event_id INTEGER) RETURNS BOOLEAN AS
$$
BEGIN
    DELETE FROM events WHERE events.EVENT_ID=event_id;
    RETURN TRUE;
END
$$
LANGUAGE plpgsql VOLATILE;

CREATE OR REPLACE FUNCTION delete_locations(location_id INTEGER) RETURNS BOOLEAN AS
$$
BEGIN
    DELETE FROM locations WHERE locations.LOCATION_ID=location_id;
    RETURN TRUE;
END
$$
LANGUAGE plpgsql VOLATILE;

CREATE OR REPLACE FUNCTION delete_battle(battle_id INTEGER) RETURNS BOOLEAN AS
$$
BEGIN
    DELETE FROM battle WHERE battle.BATTLE_ID=battle_id;
    RETURN TRUE;
END
$$
LANGUAGE plpgsql VOLATILE;

CREATE OR REPLACE FUNCTION delete_ability(ability_id INTEGER) RETURNS BOOLEAN AS
$$
BEGIN
    DELETE FROM abilities WHERE abilities.ABILITY_ID=ability_id;
    RETURN TRUE;
END
$$
LANGUAGE plpgsql VOLATILE;

CREATE OR REPLACE FUNCTION delete_character(character_id INTEGER) RETURNS BOOLEAN AS
$$
BEGIN
    DELETE FROM character WHERE character.CHARACTER_ID=character_id;
    RETURN TRUE;
END
$$
LANGUAGE plpgsql VOLATILE;